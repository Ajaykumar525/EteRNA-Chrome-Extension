diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/CalculateEnergy.c nupack3.0.4/src/thermo/utils/CalculateEnergy.c
--- nupack3.0.4_stock/src/thermo/utils/CalculateEnergy.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/CalculateEnergy.c	2020-01-11 21:06:28.000000000 -0500
@@ -13,6 +13,10 @@
 
 #include "pfuncUtilsHeader.h" //contains functions and structures
 #include "DNAExternals.h"
+
+/* for AS3 */
+extern void (*eos_cb)(int index, int fe);
+
 //***********************************************************
 
 DBL_TYPE naEnergy( char *prefix, int seq[]) {
@@ -71,7 +75,6 @@
                                           possibleSymmetry, nStrands))*kB*TEMP_K;
   energy += (BIMOLECULAR + SALT_CORRECTION)*(nStrands-1);
 
-
   free( foldFile);
   free( thefold.pairs);
   free( thefold.pknots);
@@ -149,6 +152,7 @@
   energy += LOG_FUNC( (DBL_TYPE) checkSymmetry( thefold.pairs, seqlength, nicks, 
                                            possibleSymmetry, nStrands))*kB*TEMP_K;
   energy += (BIMOLECULAR + SALT_CORRECTION)*(nStrands-1);
+  if (eos_cb && (nStrands > 1)) (*eos_cb)(-2, floor(.5 + (BIMOLECULAR + SALT_CORRECTION)*(nStrands-1)*100.));
   
   free( thefold.pairs);
   free( thefold.pknots);
@@ -168,14 +172,15 @@
   
   int pairsFromParens[ MAXSEQLENGTH];
   
-  
+
   thefold->seqlength = seqlength;
   thefold->seq = seq;
   
   pairsFromParens[0] = -5; 
-  if( parens != NULL) 
+  if( parens != NULL) {
     getStructureFromParens( parens, pairsFromParens,  
                            thefold->seqlength);
+  }
   
   thefold->pairs = 
     (int*) calloc( thefold->seqlength+1, sizeof(int));
@@ -195,14 +200,22 @@
     thefold->pairs[init] = -1;
     thefold->pknots[init] = -1;
   }
-  
+
+#if 0  
   for( init = 0; init <= thefold->seqlength - 1; init++) {
     if( parens != NULL) 
       thefold->pairs[init] = pairsFromParens[init];
     else
       thefold->pairs[init] = thepairs[init];
   }
-  
+#else
+  // it seems that the version of LLVM included in Alchemy
+  // attempts to optimize the loop above by combining it
+  // with the one below. And although only safe optimizations
+  // are allowed, the module messes up something...
+  // Temporary solution: replace the loop
+  memmove(thefold->pairs, (parens != NULL) ? pairsFromParens : thepairs, thefold->seqlength * sizeof(int));
+#endif
   
   //the following pknot finding routine should be optimized
   for( init = 0; init <= thefold->seqlength-1; init++) {
@@ -220,7 +233,6 @@
       
     }
   }
-  
 }
 
 
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/GetEnergy.c nupack3.0.4/src/thermo/utils/GetEnergy.c
--- nupack3.0.4_stock/src/thermo/utils/GetEnergy.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/GetEnergy.c	2020-03-22 16:28:26.000000000 -0400
@@ -1,10 +1,10 @@
-/* 
-   GetEnergy.c  by Robert Dirks.  
+/*
+   GetEnergy.c  by Robert Dirks.
 
    This program determines the energies of
    substructures, mirroring the loops of Fold.out
-   and includes the function for determining energies.  03/15/2001  
-   
+   and includes the function for determining energies.  03/15/2001
+
 */
 
 #include <stdio.h>
@@ -14,43 +14,47 @@
 #include "pfuncUtilsHeader.h"
 #include "DNAExternals.h"
 
+/* for AS3 */
+void (*eos_cb)(int index, int fe) = NULL;
 
 /* ******************************** */
 DBL_TYPE GetEnergy( fold *thefold) {
   DBL_TYPE energy;
-  
+
   LoadEnergies();
   energy = EnergyF( 0, thefold->seqlength - 1, thefold);
-  
+
   return energy;
 }
 
 /* ********************************* */
 DBL_TYPE EnergyF( int start, int stop, fold *thefold) {
-  
+
   DBL_TYPE energy = 0.0;
   int d; //Left end of rightmost pair or pk
-  
+
   int j;
   DBL_TYPE bp_penalty;
-  
-  j = stop; 
+  DBL_TYPE local_e = 0.0;
+  DBL_TYPE contrib;
+
+  j = stop;
   while( j >= start) {
-    
+
     if( thefold->isNicked[j]) {
 #ifdef STRUCTURE_WARNINGS
       printf("Warning, disconnected complex for:%s\n", thefold->seq);
 #endif
         return NAD_INFINITY;
     }
-    
+
     if( thefold->pknots[ j] != -1) {
       d = thefold->pknots[ j];
-      
+
       energy +=
         EnergyPk( d, j, thefold) + BETA_1 +
         DangleEnergyWithPairs( j+1, stop, thefold);
-      
+
       j = d-1;
       stop = j;
     }
@@ -65,11 +69,13 @@
         bp_penalty = AT_PENALTY;
       }
       //EnergyFb( d, j, thefold);
-      energy +=
-        EnergyFb( d, j, thefold) + 
+      contrib =
         DangleEnergyWithPairs( j+1, stop, thefold) +
         bp_penalty;
-      
+      energy +=
+        EnergyFb( d, j, thefold) + contrib;
+      local_e += contrib;
+
       j = d-1;
       stop = j;
     }
@@ -77,41 +83,44 @@
       j--;
     }
   }
-  
-  
-  energy += DangleEnergyWithPairs( start, stop, 
+
+
+  contrib = DangleEnergyWithPairs( start, stop,
                                   thefold);
-  /*  
-  energy += DangleEnergy( start, stop, 
+  energy += contrib;
+  local_e += contrib;
+  if (eos_cb) (*eos_cb)(-1, floor(.5 + local_e * 100.));
+  /*
+  energy += DangleEnergy( start, stop,
   thefold->seq, thefold->seqlength);
-  */  
-  
+  */
+
   return energy;
 }
 
 /* *************************************** */
 
 DBL_TYPE EnergyFb( int start, int stop, fold *thefold) {
-  
+
   DBL_TYPE energy = 0.0;
   int d=-1; //Left end of rightmost pair or pk
-  
+
   int i, j;
-  
+
   //int hairpin = TRUE;
   //int interiorLoop = FALSE;
   DBL_TYPE bp_penalty;
   int firstStop = stop;
-  
+
   int p1, p2;
-  
+
   int *pairs;
   int nPairs;
   int nNicks = 0;
   if(!CanPair(thefold->seq[start],thefold->seq[stop])) {
     return NAD_INFINITY;
   }
-  
+
   pairs = (int*) malloc( (thefold->seqlength)*sizeof( int) );
   pairs[0] = start;
   pairs[1] = stop;
@@ -119,21 +128,21 @@
   for( i = 2; i <= thefold->seqlength - 1; i++) {
     pairs[i] = -1;
   }
-  
-  j = stop - 1; 
+
+  j = stop - 1;
   stop = j;
   while( j >= start + 1) { //determine loop type, save pairs
     if( thefold->isNicked[j]) nNicks++;
-    
-    
+
+
     if( thefold->pknots[ j] != -1) {
-      
+
       //hairpin = interiorLoop = FALSE;
       energy += 2*ALPHA_2;
-      
+
       d = thefold->pknots[ j];
-      
-      
+
+
       if(!CanPair(thefold->seq[d],thefold->seq[thefold->pairs[d]])
           || !CanPair(thefold->seq[j], thefold->seq[thefold->pairs[j]])) {
         free(pairs);
@@ -143,16 +152,16 @@
       pairs[2*nPairs] =  d;
       pairs[2*nPairs + 1] = j;
       nPairs++;
-      
+
       //pairs[2*nPairs] = j;
       //pairs[2*nPairs + 1] = thefold->pairs[j];
-      
+
       j = d-1;
       stop = j;
     }
     else if( thefold->pairs[ j] != -1) {
       d = thefold->pairs[ j];
-      
+
       pairs[2*nPairs] =  d;
       pairs[2*nPairs + 1] = j;
       if(!CanPair(thefold->seq[d],thefold->seq[j])) {
@@ -161,60 +170,67 @@
         return NAD_INFINITY;
       }
       nPairs++;
-      
+
       if( d > j) {
         printf("Error: Unclassified pknot!\n");
         exit(1);
       }
-      
+
       j = d-1;
       stop = j;
-      
-      
+
+
     }
     else {
       j--;
     }
   }
   if( thefold->isNicked[start]) nNicks++;
-  
+
   if( nNicks >= 2) {
-#ifdef STRUCTURE_WARNINGS	
+#ifdef STRUCTURE_WARNINGS
     printf("Warning!, disconnected structure.\n");
 #endif
       free(pairs);
       pairs = NULL;
       return NAD_INFINITY;
   }
-  
+
   if( nNicks == 0) {
     if( nPairs == 1) { //hairpin
-      energy = HairpinEnergy( start, firstStop, thefold->seq);			
+      energy = HairpinEnergy( start, firstStop, thefold->seq);
+      if (eos_cb) (*eos_cb)(start, floor(.5 + energy * 100.));
       //return energy;
     }
     else if( nPairs == 2) { //interior loop
-      energy = InteriorEnergy( start, firstStop, pairs[2], pairs[3], thefold->seq)
-        + EnergyFb( pairs[2], pairs[3], thefold);
+      DBL_TYPE il_en = InteriorEnergy( start, firstStop, pairs[2], pairs[3], thefold->seq);
+      energy = il_en + EnergyFb( pairs[2], pairs[3], thefold);
+      if (eos_cb) (*eos_cb)(start, floor(.5 + il_en * 100.));
       //return energy;
     }
     else if( nPairs >= 3) { //multiloop
-      energy = ALPHA_1 + ALPHA_2 + ALPHA_3 * (pairs[1]-pairs[3]-1) + 
+      DBL_TYPE sub_en = 0.0;
+      energy = ALPHA_1 + ALPHA_2 + ALPHA_3 * (pairs[1]-pairs[3]-1) +
         DangleEnergyWithPairs(pairs[3]+1, pairs[1]-1, thefold);
-      
+
       if( thefold->seq[ pairs[0]] != BASE_C && thefold->seq[ pairs[1]] != BASE_C) {
         bp_penalty = AT_PENALTY;
       }
       else {
         bp_penalty = 0;
       }
-      
+
       for( i = 1; i < nPairs; i++) {
         if( thefold->pknots[ pairs[2*i]] == -1) { //not a pseudoknot
+          DBL_TYPE fb_en;
           if( thefold->seq[ pairs[2*i]] != BASE_C && thefold->seq[ pairs[2*i+1]] != BASE_C) {
             bp_penalty += AT_PENALTY;
           }
-          
-          energy += EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold) + ALPHA_2;
+
+          fb_en = EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold) + ALPHA_2;
+
+          energy += fb_en;
+          sub_en += fb_en;
         }
         else { //a pseudoknot
           p1 = pairs[2*i];
@@ -222,25 +238,27 @@
           if( thefold->seq[ p1 ] != BASE_C && thefold->seq[ p2] != BASE_C) {
             bp_penalty += AT_PENALTY;
           }
-          
+
           p2 = pairs[2*i+1];
           p1 = thefold->pairs[ p2 ];
           if( thefold->seq[ p1 ] != BASE_C && thefold->seq[ p2] != BASE_C) {
             bp_penalty += AT_PENALTY;
           }
-          
-          energy += EnergyPk( pairs[2*i], pairs[2*i + 1], thefold) + BETA_1M + 2*ALPHA_2;
-        }	
-        
+
+          DBL_TYPE en_pk = EnergyPk( pairs[2*i], pairs[2*i + 1], thefold) + BETA_1M + 2*ALPHA_2;
+          energy += en_pk;
+        }
+
         //reevaluate this
         p1 = 2*i;
         if( i != nPairs - 1) p2 = 2*i+3;
         else p2 = 0;
-        
-        energy += ALPHA_3*(pairs[p1] - pairs[ p2]-1) + 
+
+        energy += ALPHA_3*(pairs[p1] - pairs[ p2]-1) +
           DangleEnergyWithPairs( pairs[ p2]+1, pairs[p1]-1, thefold);
       }
       energy += bp_penalty;
+      if (eos_cb) (*eos_cb)(start, floor(.5 + (energy - sub_en) * 100.));
     }
     else {
       printf("Error in calculation of EnergyFb! %d\n", nPairs);
@@ -248,66 +266,71 @@
     }
   }
   else if( nNicks == 1) { //nNicks
+    DBL_TYPE sub_en = 0.0;
     if( thefold->seq[ pairs[0]] != BASE_C && thefold->seq[ pairs[1]] != BASE_C) {
       bp_penalty = AT_PENALTY;
     }
     else {
       bp_penalty = 0;
     }
-    
+
     if( nPairs == 1) //nicked hairpin
       energy = DangleEnergyWithPairs(pairs[0]+1, pairs[1]-1, thefold) + bp_penalty;
     else {
       energy = DangleEnergyWithPairs(pairs[3]+1, pairs[1]-1, thefold);
-      
+
       for( i = 1; i < nPairs; i++) {
+        DBL_TYPE fb_en;
         if( thefold->seq[ pairs[2*i]] != BASE_C && thefold->seq[ pairs[2*i+1]] != BASE_C) {
           bp_penalty += AT_PENALTY;
         }
-        
-        energy += EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold);
-        
+
+        fb_en = EnergyFb( pairs[2*i], pairs[ 2*i+1], thefold);
+        energy += fb_en;
+        sub_en += fb_en;
+
         p1 = 2*i;
         if( i != nPairs - 1) p2 = 2*i+3;
         else p2 = 0;
-        
+
         energy += DangleEnergyWithPairs( pairs[ p2]+1, pairs[p1]-1, thefold);
       }
       energy += bp_penalty;
       //return energy;
     }
-    
+
+    if (eos_cb) (*eos_cb)(start, floor(.5 + (energy - sub_en) * 100.));
   }
-  
+
   //#ifdef SHOWFB
   //printf("start = %d stop = %d Fb = %f\n", start, firstStop, (double) energy);
   //#endif
-  
+
   free( pairs);
   pairs = NULL;
-  
+
   return energy;
 }
 
 /* *************************************************** */
 DBL_TYPE EnergyPk( int i, int j, fold *thefold) {
-  
-  int a=0,b=0,c=0,d=0,e=0,f=0; 
-  //along with i,j these are the 
+
+  int a=0,b=0,c=0,d=0,e=0,f=0;
+  //along with i,j these are the
   //eight key points of a pseudoknots (see figure 20 of paper)
-  
+
   DBL_TYPE energy;
   int findCF, findAD;
   DBL_TYPE bp_penalty;
   int *seq = thefold->seq;
   int rightSingle;
   int leftSingle;
-  
+
   //  printf("Pk! %d %d\n", i, j);
-  
+
   e = thefold->pairs[i]; //guaranteed
   b = thefold->pairs[j]; //guaranteed
-  
+
   rightSingle = FALSE;
   findCF = FALSE;
   f = e+1; //initial guess
@@ -325,12 +348,12 @@
       }
     }
   }
-  
+
   leftSingle = FALSE;
   findAD = FALSE;
   a = b - 1; //initial guess
   while( findAD == FALSE) {
-    
+
     if( thefold->pairs[ a] != -1 && thefold->pairs[ a] >  c) {
       d = thefold->pairs[ a];
       findAD = TRUE;
@@ -344,7 +367,7 @@
       }
     }
   }
-  
+
   bp_penalty = 0;
   if( seq[ thefold->pairs[ i]] != BASE_C && seq[ thefold->pairs[ e]] != BASE_C) {
     bp_penalty += AT_PENALTY;
@@ -354,37 +377,39 @@
   }
   if( seq[ thefold->pairs[ b]] != BASE_C && seq[ thefold->pairs[ j]] != BASE_C) {
     bp_penalty += AT_PENALTY;
-  }  
+  }
   if( seq[ thefold->pairs[ c]] != BASE_C && seq[ thefold->pairs[ f]] != BASE_C) {
     bp_penalty += AT_PENALTY;
-  }   
-  
+  }
+
   energy = EnergyFg( i, a, d, e, thefold) + EnergyFg( b, c, f, j, thefold) +
-    EnergyFz( a+1, b-1, thefold) + EnergyFz( c+1, d-1, thefold) + 
+    EnergyFz( a+1, b-1, thefold) + EnergyFz( c+1, d-1, thefold) +
     EnergyFz( e+1, f-1, thefold) + 2*BETA_2 + bp_penalty;
-  
+
+  if (eos_cb) (*eos_cb)(i, floor(.5 + (energy) * 100.));
+
   //printf("PkEnergy = %f\n", energy);
   return energy;
 }
 
 /* ****************************  */
 DBL_TYPE EnergyFg( int i, int d, int e, int j, fold *thefold) {
-  
+
   DBL_TYPE energy = 0.0;
   int c=-1, f=-1; //end of rightmost pair or pk
-  
+
   DBL_TYPE multi_bp_penalty;  //bp_penalty, for the multiloop case
   int multiloop = FALSE; //extended gap
   int interiorLoop = TRUE; //regular gap
   int noPairs = TRUE; //empty gap matrix
   DBL_TYPE energyRight=0; //energy of right gap, in case it is a pk
-  
+
   int span1=-1, span2=-1;  //pair that spans the gap
   int side = 1; //1 = between e and j, -1 = between i and d
   int stop;
-  
+
   //  printf("Fg! %d %d %d %d\n", i,d,e,j);
-  
+
   //check if a single pair
   if( i == d) {
     if( e == j) {
@@ -401,13 +426,13 @@
       exit(1);
     }
   }
-  
-  
-  
+
+
+
   multi_bp_penalty = 0;
-  f = j - 1;  
+  f = j - 1;
   stop = f;
-  
+
   while( f >= i + 1) {
     //printf("f = %d\n", f);
     if( thefold->pknots[ f] != -1) {
@@ -420,13 +445,17 @@
         printf("Error: Pseudoknot spans a gap matrix!\n");
         exit(1);
       }
-      
+
       //printf("- %d %d\n", f+1, stop);
-      
-      energy +=
+
+	  DBL_TYPE en_loc =
         EnergyPk( c, f, thefold) + BETA_1M +
-        DangleEnergyWithPairs( f+1, stop, thefold) + 
+        DangleEnergyWithPairs( f+1, stop, thefold) +
         (stop - f)*ALPHA_3;
+      energy += en_loc;
+
+      if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
+
       f = c-1;
       stop = f;
     }
@@ -437,18 +466,26 @@
         exit(1);
       }
       else if( side == 1 && c < d) {
-        span1 = c; 
+        span1 = c;
         span2 = f;
         noPairs = FALSE;
         side = -1;
-        energy += EnergyFg( c,d,e,f, thefold);
-        if( thefold->seq[c] != BASE_C && thefold->seq[f] != BASE_C) {
+
+		DBL_TYPE en_loc = EnergyFg( c,d,e,f, thefold);
+
+		energy += en_loc;
+
+		if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
+
+		if( thefold->seq[c] != BASE_C && thefold->seq[f] != BASE_C) {
           multi_bp_penalty += AT_PENALTY;
         }
         //	printf("-- %d %d\n", f+1, stop);
         energyRight = DangleEnergyWithPairs( f+1, stop, thefold)
           + (stop - f)*ALPHA_3;
-        f = c-1;
+
+
+		f = c-1;
         stop = f;
       }
       else if( side == 1 && c > e) {
@@ -457,10 +494,14 @@
         multiloop = TRUE;
         //printf("c = %d, f = %d, stop = %d\n", c,f,stop);
         printf("-- %d %d\n", f+1, stop);
-        
-        energy += EnergyFb( c, f, thefold) + 
+
+		DBL_TYPE en_loc = EnergyFb( c, f, thefold) +
           DangleEnergyWithPairs( f+1, stop, thefold)
           + (stop - f)*ALPHA_3 + ALPHA_2;
+
+		energy += en_loc;
+		if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
+
         if( thefold->seq[c] != BASE_C && thefold->seq[f] != BASE_C) {
           multi_bp_penalty += AT_PENALTY;
         }
@@ -471,13 +512,17 @@
         noPairs = FALSE;
         interiorLoop = FALSE;
         multiloop = TRUE;
-        
+
         //printf("--- %d %d\n", f+1, stop);
-        
-        energy += EnergyFb( c, f, thefold) + 
+
+		DBL_TYPE en_loc = EnergyFb( c, f, thefold) +
           DangleEnergyWithPairs( f+1, stop, thefold)
           + (stop - f)*ALPHA_3 + ALPHA_2;
-        if( thefold->seq[c] != BASE_C && thefold->seq[f] != BASE_C) {
+
+        energy += en_loc;
+		if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
+
+		if( thefold->seq[c] != BASE_C && thefold->seq[f] != BASE_C) {
           multi_bp_penalty += AT_PENALTY;
         }
         f = c-1;
@@ -485,11 +530,12 @@
       }
       else if( c == d) {
         //printf("---- %d %d\n", f+1, stop);
-        
-        energyRight = 
+
+		// AMW TODO need CB?
+        energyRight =
           DangleEnergyWithPairs( f+1, stop, thefold)
           + (stop - f)*ALPHA_3;
-        
+
         side = -1;
         f = c - 1;
         stop = f;
@@ -502,54 +548,62 @@
     else {
       f--;
     }
-    
+
   }
-  
+
   if( noPairs == TRUE) {
-    energy +=  InteriorEnergy( i, j, d, e, thefold->seq);
+	DBL_TYPE en_loc = InteriorEnergy( i, j, d, e, thefold->seq);
+    energy += en_loc;
+	if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
   }
   else if( interiorLoop == TRUE) {
-    energy += InteriorEnergy( i, j, span1, span2, thefold->seq);
+    DBL_TYPE en_loc = InteriorEnergy( i, j, span1, span2, thefold->seq);
+    energy += en_loc;
+	if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
   }
   else if( multiloop == TRUE) {
     if( thefold->seq[ i] != BASE_C && thefold->seq[j] != BASE_C) {
       multi_bp_penalty += AT_PENALTY;
     }
     //printf("---!\n");
-    
-    energy += ALPHA_1 + multi_bp_penalty + 2*ALPHA_2 + 
-      (stop-i)*ALPHA_3 + 
+
+    DBL_TYPE en_loc = ALPHA_1 + multi_bp_penalty + 2*ALPHA_2 +
+      (stop-i)*ALPHA_3 +
       energyRight + DangleEnergyWithPairs( i+1, c-1, thefold);
+    energy += en_loc;
+	if (eos_cb) (*eos_cb)(i, floor(.5 + (en_loc) * 100.));
   }
   else {
     printf("Error in Fg!\n");
     exit(1);
   }
-  
+
   return energy;
 }
 
 /* ******************************************** */
 DBL_TYPE EnergyFz( int start, int stop, fold *thefold) {
-  
+
   DBL_TYPE energy = 0.0;
   int d; //Left end of rightmost pair or pk
-  
+
   DBL_TYPE bp_penalty;
   int j; //right end of pair or pk
-  
+
   //printf("Fz %d %d\n", start, stop);
-  
-  j = stop; 
+
+  j = stop;
   while( j >= start) {
     if( thefold->pknots[ j] != -1) {
       d = thefold->pknots[ j];
-      
-      energy +=
-        EnergyPk( d, j, thefold) + BETA_1P + 
+
+      DBL_TYPE en_loc =
+        EnergyPk( d, j, thefold) + BETA_1P +
         DangleEnergyWithPairs( j+1, stop, thefold) +
         BETA_3*( stop - j) + 2*BETA_2;
-      
+      energy += en_loc;
+	  if (eos_cb) (*eos_cb)(d, floor(.5 + (en_loc) * 100.)); // maybe j?
+
       j = d-1;
       stop = j;
     }
@@ -563,12 +617,14 @@
       if( thefold->seq[d] != BASE_C && thefold->seq[j] != BASE_C) {
         bp_penalty = AT_PENALTY;
       }
-      
-      energy +=
-        EnergyFb( d, j, thefold) + 
+
+      DBL_TYPE en_loc =
+        EnergyFb( d, j, thefold) +
         DangleEnergyWithPairs( j+1, stop, thefold) +
         bp_penalty + BETA_3*( stop - j) + BETA_2;
-      
+      energy += en_loc;
+	  if (eos_cb) (*eos_cb)(d, floor(.5 + (en_loc) * 100.)); // maybe j?
+
       j = d-1;
       stop = j;
     }
@@ -576,16 +632,18 @@
       j--;
     }
   }
-  
-  energy += DangleEnergyWithPairs( start, stop, thefold) +
+
+  DBL_TYPE en_loc = DangleEnergyWithPairs( start, stop, thefold) +
     BETA_3*(stop - start + 1);
-  
+  energy += en_loc;
+  if (eos_cb) (*eos_cb)(start, floor(.5 + (en_loc) * 100.)); // maybe stop?
+
   return energy;
 }
 
 /* *************************************** */
 #ifdef COAXIAL
-DBL_TYPE minCoaxialStacking( fold *thefold, int nPairs, 
+DBL_TYPE minCoaxialStacking( fold *thefold, int nPairs,
                             int *pairs, DBL_TYPE nonStackDangle) {
   /*This function will determine the minimum coaxially stacking
   configuration for a multiloop
@@ -595,85 +653,85 @@
   pairs[0]-pairs[1] is closing pair of multiloop, and remaining pairs
   pairs[2]-pairs[3] is the rightmost (3') pair in the multiloop, and
   successive pairs move from right to left
-  
+
   nPairs is the number of pairs (including the closing one
   in the multiloop.
   */
-  
+
   char *seq = thefold->seq;
   DBL_TYPE minEnergy = nonStackDangle;
   DBL_TYPE energy;
-  
+
   if( nPairs <= 2) {
     printf("Error!  Non multiloop sent to coaxially stacking subroutine!");
     exit(1);
   }
-  
+
   //first check if closing pair can stack with 5' pair
   if( pairs[0] == pairs[nPairs*2-2] - 1) {
-    
+
     energy = CoaxEnergy( seq[pairs[0]], seq[pairs[1]],
                         seq[pairs[nPairs*2-2]], seq[pairs[nPairs*2-1]]) +
       minCoax( 2, TRUE, 5, nPairs, pairs, thefold);
-    
+
     minEnergy = MIN( minEnergy, energy);
     //printf("+1 %f %f\n", energy, minEnergy);
   }
-  
+
   //next check if closing pair can stack with 3' pair
   if( pairs[1] == pairs[ 3] + 1) {
-    
-    energy = CoaxEnergy( seq[pairs[0]], seq[pairs[1]], 
-                        seq[pairs[2]], seq[pairs[3]] ) + 
+
+    energy = CoaxEnergy( seq[pairs[0]], seq[pairs[1]],
+                        seq[pairs[2]], seq[pairs[3]] ) +
       minCoax( 3, TRUE, 3, nPairs, pairs, thefold);
-    
+
     minEnergy = MIN( minEnergy, energy);
     //printf("+2 %f %f\n", energy, minEnergy);
   }
-  
+
   //next check the case where closing pair is not stacked
   energy = minCoax(2, FALSE, 0, nPairs, pairs, thefold);
   minEnergy = MIN( minEnergy, energy);
   //printf("+3 %f %f\n", energy, minEnergy);
-  
+
   return minEnergy;
 }
 
 /* ******************************** */
-DBL_TYPE minCoax( int startPair, int isPreviousPairStacked, 
+DBL_TYPE minCoax( int startPair, int isPreviousPairStacked,
                  int closingPairState,
                  int nPairs, int *pairs, fold *thefold) {
                    /* This function will determine whether or not the startPair should be
                    stacked with the pair on its 5' side (find min energy).
-                   
+
                    startPair is the current pair number being considered for stacking
                    with a pair on its left.
-                   
-                   isPreviousPairStacked indicates whether the previous pair is stacked 
+
+                   isPreviousPairStacked indicates whether the previous pair is stacked
                    or not.
-                   
+
                    closingPairState = 0 if not stacked
                    3 if stacked on the 3' side
                    5 if stacked on the 5' side
                    */
-                   
-                   
+
+
                    DBL_TYPE minEnergy = NAD_INFINITY;
                    DBL_TYPE energy;
                    int i, j, h, m;
-                   int whichDangle; //5 = 5' end only; 3 = 3' only, 53 = both  
+                   int whichDangle; //5 = 5' end only; 3 = 3' only, 53 = both
                    char *seq = thefold->seq;
-                   
-                   //printf("%d %d %d %d\n", startPair, isPreviousPairStacked, 
+
+                   //printf("%d %d %d %d\n", startPair, isPreviousPairStacked,
                    //	 closingPairState, nPairs);
-                   
+
                    if( startPair == nPairs) {
                      h = pairs[startPair*2 - 1];
                      if( closingPairState == 5) {
                        energy = 0;
                        if( isPreviousPairStacked == FALSE) {
                          energy = CoaxDangle( 3, h+1, pairs[ startPair*2-4] - 1,
-                                             thefold->pairs, thefold->seq, 
+                                             thefold->pairs, thefold->seq,
                                              thefold->seqlength);
                        }
                        //printf("- %d %d %f\n", h, pairs[ startPair*2-4], energy);
@@ -683,24 +741,24 @@
                        if( isPreviousPairStacked == TRUE) {
                          whichDangle = 5;
                        }
-                       
+
                        energy = CoaxDangle( whichDangle, h+1, pairs[ startPair*2-4] - 1,
-                                           thefold->pairs, thefold->seq, 
+                                           thefold->pairs, thefold->seq,
                                            thefold->seqlength);
-                       //printf("energy= %d %d %d %f\n", whichDangle, h+1, 
+                       //printf("energy= %d %d %d %f\n", whichDangle, h+1,
                        //pairs[ startPair*2-3] - 1, energy);
-                       
+
                        whichDangle = 53;
                        if( closingPairState == 3) {
                          whichDangle = 3;
                        }
                        energy += CoaxDangle( whichDangle, pairs[0]+1, pairs[ startPair*2-2] - 1,
-                                            thefold->pairs, thefold->seq, 
+                                            thefold->pairs, thefold->seq,
                                             thefold->seqlength);
-                       
+
                      }
                      minEnergy = MIN( energy, minEnergy);
-                     
+
                    }
                    else {
                      if( pairs[startPair*2-2] == pairs[ startPair*2+1] + 1 &&
@@ -708,63 +766,63 @@
                           //consider stacked case
                           i = pairs[ startPair*2];
                           j = pairs[ startPair*2+1];
-                          h = pairs[ startPair*2-2]; 
+                          h = pairs[ startPair*2-2];
                           m = pairs[ startPair*2-1];
-                          
+
                           energy = CoaxEnergy( seq[m], seq[h], seq[i], seq[j]);
-                          
+
                           if( isPreviousPairStacked == FALSE && startPair != 2) {
                             energy += CoaxDangle( 3, m+1, pairs[ startPair*2-4] - 1,
-                                                 thefold->pairs, thefold->seq, 
+                                                 thefold->pairs, thefold->seq,
                                                  thefold->seqlength);
                           }
                           else if( isPreviousPairStacked == FALSE) {
                             energy += CoaxDangle( 3, m+1, pairs[1] - 1,
-                                                 thefold->pairs, thefold->seq, 
+                                                 thefold->pairs, thefold->seq,
                                                  thefold->seqlength);
                           }
                           //if previous pair is stacked, there is no dangle
-                          
+
                           if( startPair != nPairs - 1) {
                             energy += minCoax( startPair+2, TRUE, closingPairState, nPairs,
                                               pairs, thefold);
                           }
                           else if( closingPairState == 0) {
                             energy += CoaxDangle( 5, pairs[0] + 1, pairs[ nPairs*2-2] - 1,
-                                                 thefold->pairs, thefold->seq, 
+                                                 thefold->pairs, thefold->seq,
                                                  thefold->seqlength);
                           }
                           //closingPairState == 3 then no dangle
-                          
+
                           minEnergy = MIN( minEnergy, energy);
                           //printf("test\n");
                         }
-                     
+
                      energy = 0;
                      whichDangle = 53;
                      if( isPreviousPairStacked == TRUE) {
                        whichDangle = 5;
                      }
-                     
+
                      h = pairs[ startPair*2 -1]; //+1
                      //consider unstacked case
                      if( startPair != 2) {
                        energy = CoaxDangle( whichDangle, h+1, pairs[ startPair*2-4] - 1,//-2
-                                           thefold->pairs, thefold->seq, 
+                                           thefold->pairs, thefold->seq,
                                            thefold->seqlength);
                      }
                      else {
                        energy = CoaxDangle( whichDangle, h+1, pairs[1] - 1,
-                                           thefold->pairs, thefold->seq, 
+                                           thefold->pairs, thefold->seq,
                                            thefold->seqlength);
                      }
-                     
+
                      energy += minCoax( startPair+1, FALSE, closingPairState, nPairs,
                                        pairs, thefold);
-                     
+
                      minEnergy = MIN( minEnergy, energy);
                    }
-                   
+
                    //printf("return %f\n", energy);
                    return minEnergy;
                  }
@@ -774,7 +832,7 @@
 DBL_TYPE CoaxEnergy( char i, char j, char h, char m) {
   DBL_TYPE energy;
   DBL_TYPE bp_bonus = 0;
-	
+
   //remove any AT_PENALTY if bases are stacked
   if( i != BASE_C && j != BASE_C) {
     bp_bonus -= AT_PENALTY;
@@ -782,9 +840,9 @@
   if( h != BASE_C && m != BASE_C) {
     bp_bonus -= AT_PENALTY;
   }
-	
-  energy = HelixEnergy(i,j,h,m) + bp_bonus;  
-  
+
+  energy = HelixEnergy(i,j,h,m) + bp_bonus;
+
   return energy;
 }
 
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/backtrack.c nupack3.0.4/src/thermo/utils/backtrack.c
--- nupack3.0.4_stock/src/thermo/utils/backtrack.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/backtrack.c	2020-01-11 21:06:28.000000000 -0500
@@ -79,7 +79,8 @@
   }
 
   for( d = i; d <= j - 1; d++) {
-   if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   //if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   if( etaN[ pf_index(IDX(d-1), IDX(d-1), seqlength)][0] == 0 || d == i ) {
      
      pf_id1 = pf_index(i,d-1,seqlength);
      
@@ -113,10 +114,12 @@
      extraTerms = DangleEnergy( i, d-1, seq, seqlength) +
        (ALPHA_3)*(d-i);
 
-     if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0) { 
        //otherwise Qm not possible
 
-       if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       //if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       if( etaN[ pf_index(IDX(i), IDX(d-1), seqlength)][0] == 0 ) {
          tempMin = Fms[ pf_index( d, j, seqlength)] + extraTerms;
          if( strcmp( type, "Fm") == 0 && WithinEps( Fm[ pf_ij], tempMin, 
              ENERGY_TOLERANCE, allowableError)) {
@@ -200,12 +203,13 @@
                 const int onlyOne) {
   
   int d; //base pair is i,d
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int pf_ij = pf_index( i, j, seqlength);
   
   DBL_TYPE extraTerms;
   int nNicks;
-  int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  //int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  int index_ij = pf_index( IDX(i), IDX(j-1), seqlength);
   int start;
   DBL_TYPE tempMin;
   
@@ -240,11 +244,11 @@
   }
 
   for( d = start; d <= j; d++) {
-    bp_penalty = 0.0;
     
     if( CanPair( seq[i], seq[ d]) == TRUE &&
        ( seq[i]) + ( seq[d]) == 5) {
 
+         bp_penalty = 0.0;
          if( seq[i] != BASE_C && seq[d] != BASE_C) {
            bp_penalty = AT_PENALTY;
          }
@@ -413,7 +417,7 @@
   // Decomposes the region inside pair i,j into multiloops, i.e.
   // and excludes the possibility of "top level" nicks
 
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   DBL_TYPE extraTerms;
   DBL_TYPE tempMin;
   int pf_ij = pf_index(i, j, seqlength);
@@ -439,11 +443,12 @@
 
   if( ( seq[i]) + ( seq[j]) == 5) {
     for( d = i+3; d <= j - 2; d++) {
-      //reset loop parameters
-      bp_penalty = 0.0;
 
-      if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0 ) {
         
+        //reset loop parameters
+        bp_penalty = 0.0;
         if( seq[i] != BASE_C  && seq[j] != BASE_C) {
           bp_penalty += AT_PENALTY;
         }
@@ -494,7 +499,7 @@
                         const int onlyOne) {
 
   DBL_TYPE tempMin;
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int multiNick = -1;
   int index_ij;
   int leftIndex;
@@ -523,13 +528,16 @@
   //PrintS( &rootStr);
   
   
-  index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  //index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  index_ij = pf_index(IDX(i), IDX(j-1), seqlength);
   
   iNicked = jNicked = FALSE;
-  if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(j-1), IDX(j-1), seqlength)][0] != 0) {
     jNicked = TRUE;
   }
-  if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(i), IDX(i), seqlength)][0] != 0) {
     iNicked = TRUE;
   }
 
@@ -631,8 +639,10 @@
   for( L = j-i-2; L >= j-i-2-maxILoopSize[pf_ij]; L--) { 
     for( d = i+1; d <= j-L-1; d++) {
       e = d+L;
-      if( CanPair( seq[d], seq[e]) && etaN[ EtaNIndex( i+0.5, d-0.5, seqlength)][0] == 0 &&
-         etaN[ EtaNIndex( e+0.5, j-0.5, seqlength)][0] == 0) {
+      //if( CanPair( seq[d], seq[e]) && etaN[ EtaNIndex( i+0.5, d-0.5, seqlength)][0] == 0 &&
+         //etaN[ EtaNIndex( e+0.5, j-0.5, seqlength)][0] == 0) {
+      if( CanPair( seq[d], seq[e]) && etaN[ pf_index( IDX(i), IDX(d-1), seqlength)][0] == 0 &&
+         etaN[ pf_index( IDX(e), IDX(j-1), seqlength)][0] == 0) {
         energy = InteriorEnergy( i,j,d,e,seq) + Fb[ pf_index(d,e,seqlength)];
         if( WithinEps( Fb[ pf_ij], energy, ENERGY_TOLERANCE, allowableError)) {
 
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/ene.c nupack3.0.4/src/thermo/utils/ene.c
--- nupack3.0.4_stock/src/thermo/utils/ene.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/ene.c	2020-01-11 21:06:28.000000000 -0500
@@ -71,10 +71,10 @@
 
   extern DBL_TYPE MMEnergiesIL[];
   int cp_shift;
-  DBL_TYPE energy = 0.0;
+  DBL_TYPE energy;
 
   cp_shift = GetMismatchShift( a, b );
-  energy = MMEnergiesIL[ (4*(( x) - 1) + (( y) - 1) )*6 + cp_shift];
+  energy = MMEnergiesIL[ (((( x) - 1)<<2) + (( y) - 1) )*6 + cp_shift];
 
   return energy;
 }
@@ -133,11 +133,11 @@
       energy += AT_PENALTY;
     }
 
-    triloopnumber = 256*(( seq[i]) - 1) +
-      64*(( seq[i + 1]) - 1) +
-      16*(( seq[i + 2]) - 1) +
-      4*( ( seq[j - 1]) - 1) +
-      1*( ( seq[j]) - 1);
+    triloopnumber = ((( seq[i]) - 1)<<8) +
+      ((( seq[i + 1]) - 1)<<6) +
+      ((( seq[i + 2]) - 1)<<4) +
+      (( ( seq[j - 1]) - 1)<<2) +
+      ( ( seq[j]) - 1);
 
     // 0 mismatch energy for triloops
     energy += triloop_energy[ triloopnumber];
@@ -149,18 +149,18 @@
   }
   else if (size == 4) {
 
-    tloopnumber = 1024*(( seq[i]) - 1) +
-      256*(( seq[i + 1]) - 1) +
-      64*( ( seq[i + 2]) - 1) +
-      16*( ( seq[j - 2]) - 1) +
-      4*(  ( seq[j - 1]) - 1) +
-      1*(  ( seq[j])- 1);
+    tloopnumber = ((( seq[i]) - 1)<<10) +
+      ((( seq[i + 1]) - 1)<<8) +
+      (( ( seq[i + 2]) - 1)<<6) +
+      (( ( seq[j - 2]) - 1)<<4) +
+      ((  ( seq[j - 1]) - 1)<<2) +
+      (  ( seq[j])- 1);
     energy +=  tloop_energy[ tloopnumber];
 
     //Next do mismatches.
     cp_shift = GetMismatchShift( seq[i], seq[j]);
 
-    energy += MMEnergiesHP[(4*(( seq[i + 1]) - 1) +
+    energy += MMEnergiesHP[(((( seq[i + 1]) - 1)<<2) +
                             (( seq[j - 1]) - 1) )*6
                            + cp_shift];
     //Poly-C loop
@@ -173,7 +173,7 @@
     // Calculate mismatch
     cp_shift = GetMismatchShift( seq[i], seq[j]);
 
-    energy += MMEnergiesHP[(4*(( seq[i + 1]) - 1) +
+    energy += MMEnergiesHP[(((( seq[i + 1]) - 1)<<2) +
                             (( seq[j - 1]) - 1) )*6
                            + cp_shift];
 
@@ -192,6 +192,8 @@
   return InteriorEnergyFull( i, j, h, m, seq, TRUE);
 }
 
+DBL_TYPE (*binding_site_cb)(int i, int j, int h, int m) = NULL;
+
 DBL_TYPE InteriorEnergyFull( int i, int j, int h, int m, int seq[],
                              int calcIJ) {
 
@@ -276,18 +278,18 @@
         cp_shift = GetMismatchShift( seq[i], seq[j]);
         ip_shift = GetMismatchShift( seq[h], seq[m]);
         if (cp_shift==-1 || ip_shift==-1) return 0.0; //Wrongly called 
-        energy += IL_SInt2[ 96*cp_shift + 16*ip_shift +
-                           4*(( seq[i+1]) - 1) +
+        energy += IL_SInt2[ 96*cp_shift + (ip_shift<<4) +
+                           ((( seq[i+1]) - 1)<<2) +
                            (( seq[ j -1]) - 1) ];
       }
       else if( asymmetry == 0 && size == 4) {
         cp_shift = GetMismatchShift( seq[i], seq[j]);
         ip_shift = GetMismatchShift( seq[h], seq[m]);
         if (cp_shift==-1 || ip_shift==-1) return 0.0; //Wrongly called 
-        energy += IL_SInt4[ cp_shift*256*6 +  ip_shift*256 +
-                           (4*(( seq[ i+1])  - 1) +
-                            ( seq[ j - 1])   - 1)*16 +
-                           (4*( ( seq[ i+2]) - 1) +
+        energy += IL_SInt4[ cp_shift*256*6 +  (ip_shift<<8) +
+                           ((((( seq[ i+1])  - 1)<<2) +
+                            ( seq[ j - 1])   - 1)<<4) +
+                           ((( ( seq[ i+2]) - 1)<<2) +
                             ( seq[ j - 2])   - 1) ];
       }
       else if( asymmetry == 1 && L1 == 1) {
@@ -297,7 +299,7 @@
         energy += IL_AsInt1x2[ cp_shift*4*24*4 +
                               (( seq[ j - 2]) - 1)*24*4 +
                               (( seq[ i + 1]) - 1)*24 +
-                              4*ip_shift +
+                              (ip_shift<<2) +
                               ((( seq[ j - 1]) - 1) % 4) ];
       }
       else if( asymmetry == 1 && L1 == 2) {
@@ -310,7 +312,7 @@
         energy += IL_AsInt1x2[ ip_shift*4*24*4 +
                               (( seq[i + 1]) - 1)*24*4 +
                               (( seq[j - 1]) - 1)*24 +
-                              4*cp_shift +
+                              (cp_shift<<2) +
                               ((( seq[i + 2]) - 1) % 4) ];
       }
       else {
@@ -324,6 +326,9 @@
     exit(1);
   }
 
+  if (binding_site_cb != NULL)
+    energy += (*binding_site_cb)(i, j, h, m);
+
   return energy;
 }
 
@@ -373,7 +378,7 @@
     }
 #endif
     if( j != -1)
-      dangle3 = dangle_energy[ 24 + dangle_shift*4 + ( seq[ j]) - 1];
+      dangle3 = dangle_energy[ 24 + (dangle_shift<<2) + ( seq[ j]) - 1];
   }
 
   if( i == 0) {
@@ -391,7 +396,7 @@
     }
 #endif
     if( i != seqlength)
-      dangle5 = dangle_energy[ dangle_shift*4 + ( seq[ i]) - 1];
+      dangle5 = dangle_energy[ (dangle_shift<<2) + ( seq[ i]) - 1];
   }
 
   if( DANGLETYPE != 2 && j == i - 1) {
@@ -461,7 +466,7 @@
       //exit(1);
     }
 #endif
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 + ( seq[ j]) - 1];
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) + ( seq[ j]) - 1];
   }
 
   if( i == 0) {
@@ -479,7 +484,7 @@
     }
 #endif
 
-    dangle5 = dangle_energy[ dangle_shift*4 +
+    dangle5 = dangle_energy[ (dangle_shift<<2) +
                             ( seq[ i]) - 1];
   }
 
@@ -538,7 +543,7 @@
       exit(-1);
     }
     dangle_shift = 3 - pt;
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 +
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) +
                             ( seq[ j]) - 1];
   }
 
@@ -553,7 +558,7 @@
     }
 
     dangle_shift = pt;
-    dangle5 = dangle_energy[ dangle_shift*4 +
+    dangle5 = dangle_energy[ (dangle_shift<<2) +
                             ( seq[ i]) - 1];
   }
 
@@ -586,7 +591,7 @@
   }
   else {
     dangle_shift = 3 - GetPairType( seq[ j + 1]);
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 + 
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) + 
                             seq[ j] - 1];
   }
   
@@ -595,7 +600,7 @@
   }
   else {
     dangle_shift = GetPairType( seq[i-1]);
-    dangle5 = dangle_energy[ dangle_shift*4 + 
+    dangle5 = dangle_energy[ (dangle_shift<<2) + 
                             seq[ i] - 1];
   }
   
@@ -659,10 +664,12 @@
   nick = -5;
 
   if( i != 0) { //if j == seqlength -1, this is still OK
-    nIndex = EtaNIndex( i-0.5, j+0.5, seqlength);
+    //nIndex = EtaNIndex( i-0.5, j+0.5, seqlength);
+    nIndex = pf_index( IDX(i-1), IDX(j), seqlength);
   }
   else {
-    nIndex = EtaNIndex( i+0.5, j+0.5, seqlength);
+    //nIndex = EtaNIndex( i+0.5, j+0.5, seqlength);
+    nIndex = pf_index( IDX(i), IDX(j), seqlength);
   }
 
   if( etaN[ nIndex][0] >= 2 ||
@@ -697,7 +704,7 @@
       dangle_shift = GetMismatchShift( seq[i-1], seq[j+1]);
     }
 
-    dangle3 = dangle_energy[ 24 + dangle_shift*4 +
+    dangle3 = dangle_energy[ 24 + (dangle_shift<<2) +
                             ( seq[ j]) - 1];
   }
 
@@ -712,7 +719,7 @@
       dangle_shift = GetMismatchShift( seq[i-1], seq[j+1]);
     }
 
-    dangle5 = dangle_energy[ dangle_shift*4 +
+    dangle5 = dangle_energy[ (dangle_shift<<2) +
                             ( seq[ i]) - 1];
   }
 
@@ -740,7 +747,8 @@
 DBL_TYPE NickedEmptyQ( int i, int j, const int nicks[], int seq[],
                       int seqlength, int **etaN) {
 
-  if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
+  //if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
+  if( j <= i || etaN[ pf_index( IDX(i), IDX(j-1), seqlength)][0] == 0) {
     return EXP_FUNC( -1*NickDangle(i, j, nicks, etaN,
                               FALSE, seq, seqlength)
                 /(kB*TEMP_K));
@@ -754,13 +762,14 @@
 /* ******** */
 DBL_TYPE NickedEmptyF( int i, int j, const int nicks[], int seq[],
                        int seqlength, int **etaN) {
-  DBL_TYPE result = NAD_INFINITY;
+  DBL_TYPE result;
 
-  if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
-    result = NickDangle(i, j, nicks, etaN, FALSE, seq, seqlength);
+  //if( j <= i || etaN[ EtaNIndex( i+0.5, j-0.5, seqlength)][0] == 0) {
+  if( j <= i || etaN[ pf_index( IDX(i), IDX(j-1), seqlength)][0] == 0) {
+    return NickDangle(i, j, nicks, etaN, FALSE, seq, seqlength);
   }
 
-  return result;
+  return NAD_INFINITY;
 }
 
 /* ********* */
@@ -774,7 +783,11 @@
   return EXP_FUNC( - energy/( kB*TEMP_K));
 }
 
-DBL_TYPE sizeLog(int size){
+DBL_TYPE sizeLog(int size) {
+  return (1.75 * kB) * TEMP_K * LOG_FUNC(size / 30.0);
+}
+
+DBL_TYPE sizeLogCache(int size){
   static DBL_TYPE *slCache[MAXSTRANDS], *edc, tc;
   static int CacheInd=-1, nCaches=0;
   static DBL_TYPE TCache[MAXSTRANDS];
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/init.c nupack3.0.4/src/thermo/utils/init.c
--- nupack3.0.4_stock/src/thermo/utils/init.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/init.c	2020-01-11 21:06:28.000000000 -0500
@@ -418,16 +418,18 @@
   // Allocate and deallocate Fx matrices
   
   int i;
-  int maxStorage;
+  static int maxStorage = 0;
+  static DBL_TYPE* Fc = NULL;
   DBL_TYPE *temp;
   
-  maxStorage = (seqlength - len)*(len - 1);
-  for( i = len+1; i <= len + 2; i++) {
-    maxStorage = MAX( maxStorage, ( seqlength - i)*(i - 1) );
-  }
-  
-  
   if( len == 11) { //first use of these matrices
+    maxStorage = (seqlength - len)*(len - 1);
+    for( i = len+1; i < seqlength; i++) {
+      maxStorage = MAX( maxStorage, ( seqlength - i)*(i - 1) );
+    }
+    
+    if (Fc) free(Fc);
+    Fc = (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
     *Fx = (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
     *Fx_1 = 
       (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
@@ -438,9 +440,13 @@
       fprintf(stderr, "Error in Fx, Fx_1, Fx_2 allocation\n");
     }
     
-    for( i = 0; i < maxStorage; i++) 
-      (*Fx)[i] = (*Fx_1)[i] = (*Fx_2)[i] = NAD_INFINITY;
-    
+    for( i = 0; i < maxStorage; i++)
+      Fc[i] = NAD_INFINITY;
+      // (*Fx)[i] = (*Fx_1)[i] = (*Fx_2)[i] = NAD_INFINITY;
+    
+    memmove(*Fx, Fc, maxStorage * sizeof(DBL_TYPE));
+    memmove(*Fx_1, Fc, maxStorage * sizeof(DBL_TYPE));
+    memmove(*Fx_2, Fc, maxStorage * sizeof(DBL_TYPE));
   }
   
   else if( len > 11) {
@@ -448,6 +454,9 @@
     temp = *Fx;
     *Fx = *Fx_1;
     *Fx_1 = *Fx_2;
+    *Fx_2 = temp;
+    memmove(*Fx_2, Fc, maxStorage * sizeof(DBL_TYPE));
+/*
     free( temp);
     *Fx_2 =
       (DBL_TYPE *) calloc( maxStorage, sizeof( DBL_TYPE));
@@ -457,6 +466,7 @@
     }
     for( i = 0; i < maxStorage; i++) 
       (*Fx_2)[i] = NAD_INFINITY;
+*/
     
   }
 }
@@ -1854,11 +1864,15 @@
   
   int i,j,k, nick;
   int indexE;
+
+  int arraySize = seqlength*(seqlength+1)/2 + (seqlength+1);
+  int* blk = (int*) malloc( arraySize*2*sizeof( int));
   
   for( i = 0; i <= seqlength-1; i++) {
     for( j = i-1; j <= seqlength-1; j++) {
       indexE = pf_index( i, j, seqlength);
-      etaN[ indexE] = (int *) malloc( 2*sizeof( int));
+      //etaN[ indexE] = (int *) malloc( 2*sizeof( int));
+      etaN[ indexE] = blk + 2*indexE;
       etaN[ indexE][0] = 0;
       etaN[ indexE][1] = -1;
       
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/mfeUtils.c nupack3.0.4/src/thermo/utils/mfeUtils.c
--- nupack3.0.4_stock/src/thermo/utils/mfeUtils.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/mfeUtils.c	2020-03-19 20:47:34.000000000 -0400
@@ -29,6 +29,7 @@
 #include <stdlib.h>
 #include <math.h>
 #include <time.h>
+#include <sys/time.h>
 
 #include "pfuncUtilsHeader.h"
 
@@ -37,52 +38,52 @@
 int containsPk;
 /* End Global Variables */
 
+void TraceJS(char* text);
 
 /* ****************************** */
 // This is the main MFE calculator.  Actually finds all suboptimal folds
 // with energy below fixedSubOptRange, which if < 0, does MFE
-DBL_TYPE mfeFullWithSym_SubOpt( int inputSeq[], int seqLen, 
-                               dnaStructures *mfeStructures, int complexity, int naType, 
+DBL_TYPE mfeFullWithSym_SubOpt( int inputSeq[], int seqLen,
+                               dnaStructures *mfeStructures, int complexity, int naType,
                                int dangles, DBL_TYPE temperature, int symmetry, DBL_TYPE fixedSubOptRange,
-                               int onlyOne, DBL_TYPE sodiumconc, DBL_TYPE magnesiumconc, 
+                               int onlyOne, DBL_TYPE sodiumconc, DBL_TYPE magnesiumconc,
                                int uselongsalt) {
-                                 
-  //if fixedSubOptRange > 0, then enumerate all structures with fsor, rather than find mfe
 
+  //if fixedSubOptRange > 0, then enumerate all structures with fsor, rather than find mfe
   DBL_TYPE result;
   int seqlength;
 
-  DBL_TYPE *F = NULL;
-  DBL_TYPE *Fb = NULL;
-  DBL_TYPE *Fm = NULL;
+  static DBL_TYPE *F = NULL;
+  static DBL_TYPE *Fb = NULL;
+  static DBL_TYPE *Fm = NULL;
 
   //N^3
-  DBL_TYPE *Fx = NULL;
-  DBL_TYPE *Fx_1 = NULL;
-  DBL_TYPE *Fx_2 = NULL;
-  DBL_TYPE *Fs = NULL;
-  DBL_TYPE *Fms = NULL;
+  static DBL_TYPE *Fx = NULL;
+  static DBL_TYPE *Fx_1 = NULL;
+  static DBL_TYPE *Fx_2 = NULL;
+  static DBL_TYPE *Fs = NULL;
+  static DBL_TYPE *Fms = NULL;
 
   //PKNOTS
-  DBL_TYPE *Fp = NULL;
-  DBL_TYPE *Fz = NULL;  //O(N^2)
-  DBL_TYPE *Fg = NULL; //O(N^4)
+  static DBL_TYPE *Fp = NULL;
+  static DBL_TYPE *Fz = NULL;  //O(N^2)
+  static DBL_TYPE *Fg = NULL; //O(N^4)
 
   //N^5
-  DBL_TYPE *FgIx = NULL;
-  DBL_TYPE *FgIx_1 = NULL;
-  DBL_TYPE *FgIx_2 = NULL;
-  DBL_TYPE *Fgls = NULL;
-  DBL_TYPE *Fgrs = NULL;
+  static DBL_TYPE *FgIx = NULL;
+  static DBL_TYPE *FgIx_1 = NULL;
+  static DBL_TYPE *FgIx_2 = NULL;
+  static DBL_TYPE *Fgls = NULL;
+  static DBL_TYPE *Fgrs = NULL;
 
-  DBL_TYPE *Fgl = NULL;
-  DBL_TYPE *Fgr = NULL; //O(N^4) space
+  static DBL_TYPE *Fgl = NULL;
+  static DBL_TYPE *Fgr = NULL; //O(N^4) space
 
   /*  F-type matrices are dynamically allocated matrices that
   contain minimum energies restricted to a subsequence of the
   strand.  Each of the above should be accessed by the call
   F[ pf_index(i, j, seqlength)] to indicate the partition function between
-  i and j, inclusive. 
+  i and j, inclusive.
 
   Descriptions of each are in the referenced paper (see pfunc.c)
   */
@@ -95,6 +96,7 @@
   DBL_TYPE tempMin;
 
   extern long int maxGapIndex;
+  static long int last_maxGapIndex;
   short *possiblePairs;
 
   int nicks[ MAXSTRANDS];  //the entries must be strictly increasing
@@ -102,6 +104,7 @@
 
   int **etaN;
   int arraySize;
+  static int last_arraySize = 0;
   int nStrands;
   int *seq;
   int *foldparens;
@@ -113,8 +116,10 @@
   DBL_TYPE localEnergy;
   int oldp1;
   int symmetryOfStruct = 1; // Must be initialized
-  int *thepairs;  
+  int *thepairs;
 
+  struct timeval start;
+  gettimeofday(&start, NULL);
 
   //assign global variables
   TEMP_K = temperature + ZERO_C_IN_KELVIN;
@@ -124,7 +129,7 @@
   MAGNESIUM_CONC = magnesiumconc;
   USE_LONG_HELIX_FOR_SALT_CORRECTION = uselongsalt;
 
-  // Get dG_salt. It will be used to calculate 
+  // Get dG_salt. It will be used to calculate
   DBL_TYPE salt_correction = computeSaltCorrection(sodiumconc,magnesiumconc,uselongsalt);
 
   seqlength = getSequenceLengthInt( inputSeq, &nStrands);
@@ -156,12 +161,21 @@
   if( complexity >= 5) //pseudoknotted
    initMfe( seqlength);
 
+#define MATRIX_INIT(M,S,AS,T) do { \
+  if (S > AS || M == NULL) { \
+    if (M) free(M); \
+    InitLDoublesMatrix(&M, S, T); \
+  } \
+} while(0)
 
   arraySize = seqlength*(seqlength+1)/2 + (seqlength+1);
   // Allocate and Initialize Matrices
-  InitLDoublesMatrix( &F, arraySize, "F");
-  InitLDoublesMatrix( &Fb, arraySize, "Fb");
-  InitLDoublesMatrix( &Fm, arraySize, "Fm");
+  MATRIX_INIT(F, arraySize, last_arraySize, "F");
+  //InitLDoublesMatrix( &F, arraySize, "F");
+  MATRIX_INIT(Fb, arraySize, last_arraySize, "Fb");
+  //InitLDoublesMatrix( &Fb, arraySize, "Fb");
+  MATRIX_INIT(Fm, arraySize, last_arraySize, "Fm");
+  //InitLDoublesMatrix( &Fm, arraySize, "Fm");
 
   etaN = (int**) malloc( arraySize*sizeof( int*));
   InitEtaN( etaN, nicks, seqlength);
@@ -170,15 +184,17 @@
   minILoopEnergyBySize = (DBL_TYPE*) malloc( seqlength*sizeof( DBL_TYPE));
 
   if( complexity == 3) {
-   InitLDoublesMatrix( &Fs, arraySize, "Fs");
-   InitLDoublesMatrix( &Fms, arraySize, "Fms");
+   MATRIX_INIT(Fs, arraySize, last_arraySize, "Fs");
+   //InitLDoublesMatrix( &Fs, arraySize, "Fs");
+   MATRIX_INIT(Fms, arraySize, last_arraySize, "Fms");
+   //InitLDoublesMatrix( &Fms, arraySize, "Fms");
   }
 
   if( complexity >= 5) {
    InitLDoublesMatrix( &Fp, arraySize, "Fp");
    InitLDoublesMatrix( &Fz, arraySize, "Fz");
    InitLDoublesMatrix( &Fg, maxGapIndex, "Fg");
-   
+
    if( complexity == 5) {
      InitLDoublesMatrix( &Fgl, maxGapIndex, "Fgl");
      InitLDoublesMatrix( &Fgr, maxGapIndex, "Fgr");
@@ -188,22 +204,24 @@
    }
   }
 
+  last_arraySize = arraySize;
+
   //Initialization to NAD_INFINITY
 
-  if( complexity >= 5) 
+  if( complexity >= 5)
    maxIndex = maxGapIndex; //beware overflow
   else
    maxIndex = arraySize;
 
-  for( i = 0; i < maxIndex; i++) {    
+  for( i = 0; i < maxIndex; i++) {
    if(  i < arraySize ) {
-     F[i] = Fb[i] = Fm[i] = NAD_INFINITY; 
+     F[i] = Fb[i] = Fm[i] = NAD_INFINITY;
      if( complexity == 3)
        Fs[i] = Fms[i] = NAD_INFINITY;
-     
-     if( complexity >= 5) 
-       Fp[i] = Fz[i] = NAD_INFINITY; 
-   } 
+
+     if( complexity >= 5)
+       Fp[i] = Fz[i] = NAD_INFINITY;
+   }
    if( complexity >= 5) {
      Fg[i] = NAD_INFINITY;
      if( complexity == 5)
@@ -214,7 +232,7 @@
   for( i = 0; i <= seqlength; i++) {
    pf_ij = pf_index( i, i-1, seqlength);
    F[ pf_ij] = NickDangle(i, i-1, nicks, etaN, FALSE, seq, seqlength);
-   
+
    if( complexity >= 5)
      Fz[ pf_ij] = F[ pf_ij];
   }
@@ -226,26 +244,26 @@
     int iMin = 0;
     int iMax = seqlength - L;
 
-   
-    if( complexity == 3) 
-      manageFx( &Fx, &Fx_1, &Fx_2, L-1, seqlength);   
+
+    if( complexity == 3)
+      manageFx( &Fx, &Fx_1, &Fx_2, L-1, seqlength);
    //allocate/deallocate memory
-   
-    if( complexity == 5) 
+
+    if( complexity == 5)
       manageFgIx( &FgIx, &FgIx_1, &FgIx_2, L-1, seqlength);
-   //manageQgIx manages the temporary matrices needed for 
+   //manageQgIx manages the temporary matrices needed for
    //calculating Qg_closed in time n^5
-   
+
     for( i = iMin; i <= iMax; i++) {
       j = i + L - 1;
       pf_ij = pf_index( i, j, seqlength);
-     
+
      //store the maximum iloop size with mfeEpsilon of mfe
      for( k = 0; k < L; k++) minILoopEnergyBySize[k] = NAD_INFINITY; //initialize to zero;
-     
+
      /* Recursions for Fb */
      /* bp = base pairs, pk = pseudoknots */
-     
+
      min_energy = NAD_INFINITY;
      if( CanPair( seq[ i], seq[ j]) == FALSE) {
        Fb[ pf_ij] = NAD_INFINITY;
@@ -253,125 +271,128 @@
      else {
        min_energy = MinHairpin( i, j, seq, seqlength, etaN);
        // Exactly 1 bp
-       
+
        if( complexity == 3) {
-         if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
-            etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] == 0) {
+         //if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
+         //   etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] == 0) {
+         if( etaN[ pf_index(IDX(i), IDX(i), seqlength)][0] == 0 &&
+            etaN[ pf_index(IDX(j-1), IDX(j-1), seqlength)][0] == 0) {
               //regular multiloop.  No top-level nicks
-              
+
               tempMin = MinMultiloops(i, j, seq, Fms, Fm,
                                       seqlength, etaN);
               min_energy = MIN( tempMin, min_energy);
             }
-         
-         if( etaN[ EtaNIndex(i+0.5, j-0.5, seqlength)][0] >= 1) {
+
+         //if( etaN[ EtaNIndex(i+0.5, j-0.5, seqlength)][0] >= 1) {
+         if( etaN[ pf_index(IDX(i), IDX(j-1), seqlength)][0] >= 1) {
            //Exterior loop (created by nick)
-           tempMin = MinExteriorLoop( i, j, seq, seqlength, 
-                                     F, nicks, etaN); 
+           tempMin = MinExteriorLoop( i, j, seq, seqlength,
+                                     F, nicks, etaN);
            min_energy = MIN( tempMin, min_energy);
          }
        }
-       
+
        if( complexity != 3) {
          // Interior Loop and Multiloop Case
          tempMin = MinInterior_Multi( i, j, seq, seqlength, Fm, Fb, nicks, etaN);
          min_energy = MIN( tempMin, min_energy);
        }
-       
+
        if( complexity >= 5) {
-         
+
          tempMin =  MinFb_Pk( i, j, seq, seqlength, Fp, Fm );
          min_energy = MIN( tempMin, min_energy);
        }
-       
+
      }
-     
-     if( complexity == 3) 
+
+     if( complexity == 3)
        MinFastILoops( i, j, L, seqlength, seq, etaN, Fb, Fx, Fx_2, minILoopEnergyBySize);
-     
+
      Fb[pf_ij] = MIN( Fb[ pf_ij], min_energy);
 
      maxILoopSize[ pf_ij] = 0;
-     if( CanPair( seq[i], seq[j]) == TRUE) { 
-       
+     if( CanPair( seq[i], seq[j]) == TRUE) {
+
        for( k = 0; k < L; k++) {
         if( minILoopEnergyBySize[k] < Fb[ pf_ij] + mfeEpsilon + ENERGY_TOLERANCE ) {
          maxILoopSize[ pf_ij] = k;
         }
        }
      }
-     
-     
+
+
      // Recursions for Fg, Fgls, Fgrs, Fgl, Fgr
      if( complexity == 5) {
        MakeFg_N5(i, j, seq, seqlength, Fg, Fm, Fgls, Fgrs, FgIx, FgIx_2,
                  possiblePairs);
-       
+
        MakeFgls( i, j, seq, seqlength, Fg, Fm, Fgls);
        MakeFgrs( i, j, seq, seqlength, Fg, Fm, Fgrs);
        MakeFgl(i, j, seq, seqlength, Fg, Fgl, Fz);
        MakeFgr(i, j, seq, seqlength, Fgr, Fgl, Fz);
-       
+
        Fp[ pf_ij] = MinFp_N5( i, j, seq, seqlength, Fgl, Fgr, Fg, Fz);
      }
      else if( complexity == 8) {
        //MakeFg_N8( i, j, seq, seqlength, Fg, Fm);
        //Fp[ pf_ij] = MinFp_N8( i, j, seq, seqlength, Fg, Fz);
      }
-     
-     
+
+
      if( complexity == 3) {
        /* Recursions for Fms, Fs */
        MakeFs_Fms( i, j, seq, seqlength, Fs, Fms, Fb, nicks, etaN);
-       
+
        /* Recursions for Q, Qm, Qz */
        MakeF_Fm_N3( i, j, seq, seqlength, F, Fs, Fms, Fm,
-                   nicks,etaN);  
+                   nicks,etaN);
      }
-     
+
 #ifdef test
-     if( complexity == 4) 
+     if( complexity == 4)
         MakeF_Fm_N4( i, j, seq, seqlength, F, Fm, Fb);
 #endif
       if( complexity >= 5)
         MakeF_Fm_Fz(i, j, seq, seqlength, F, Fm, Fz, Fb, Fp);
-     
+
     }
   }
-    result = F[ pf_index(0,seqlength-1,seqlength)];  
+    result = F[ pf_index(0,seqlength-1,seqlength)];
     if( result < NAD_INFINITY/2.0) {
 
      initMfeStructures( mfeStructures, seqlength);
      if( complexity == 3) {
-       
+
        if( fixedSubOptRange <= 0) {
          bktrF_Fm_N3( 0, seqlength - 1, seq, seqlength, F, Fb, Fm, Fs, Fms,
                      nicks, etaN, mfeStructures, "F", maxILoopSize, 0, onlyOne && !NUPACK_VALIDATE);
          thepairs = mfeStructures->validStructs[0].theStruct;
-         
+
          symmetryOfStruct = checkSymmetry( thepairs, seqlength, nicks, symmetry,
                                           nStrands);
-         
+
          // THIS IS WHERE WE KNOW WHETHER OR NOT WE HAVE TO DO THE ENUMERATION
-         
+
          mfeEpsilon = kB*TEMP_K*LOG_FUNC( (DBL_TYPE) symmetryOfStruct);
          //default search space is within RT log( sym) of the mfe
-         
+
          if( mfeEpsilon > ENERGY_TOLERANCE) {
-           for( i = 0; i < seqlength; i++) { 
+           for( i = 0; i < seqlength; i++) {
              //check structures that differ by one base pair before doing full enumeration
              oldp1 = thepairs[i];
              if( oldp1 >= 0) {
                thepairs[i] = -1;
                thepairs[ oldp1] = -1;
-               
+
                //no symmetry is possible if the original structure was symmetric
                localEnergy = naEnergyPairsOrParensFull( thepairs, NULL, inputSeq, naType,
                     dangles, temperature, SODIUM_CONC,
-                    MAGNESIUM_CONC, 
-                    USE_LONG_HELIX_FOR_SALT_CORRECTION) - 
+                    MAGNESIUM_CONC,
+                    USE_LONG_HELIX_FOR_SALT_CORRECTION) -
                  ( BIMOLECULAR + SALT_CORRECTION ) *(nStrands-1); //for comparison purposes, remove bimolecular term
-               
+
                mfeEpsilon = MIN( mfeEpsilon, localEnergy - result);
 
                thepairs[i] = oldp1;
@@ -391,16 +412,16 @@
     }
     else if( complexity == 5) {
       if( fixedSubOptRange < 0) mfeEpsilon = 0;
-      
+
       bktrF_Fm_FzN5( 0, seqlength - 1, seq, seqlength, F, Fb, Fm, Fp,
                     Fz, Fg, Fgls, Fgrs, Fgl, Fgr, mfeStructures, nicks,
                     etaN, mfeEpsilon, "F");
     }
 #ifdef test
     else if( complexity == 4)
-       bktrF_Fm_N4( 0, seqlength - 1, seq, seqlength, result, F, Fb, Fm, 
+       bktrF_Fm_N4( 0, seqlength - 1, seq, seqlength, result, F, Fb, Fm,
                   , "F");
-    else if( complexity == 8) 
+    else if( complexity == 8)
        bktrF_Fm_FzN8( 0, seqlength - 1, seq, seqlength, result, F, Fb, Fm, Fp,
                     Fz, Fg, thepairs, "F");
 #endif
@@ -443,10 +464,10 @@
       qsort( mfeStructures->validStructs, mfeStructures->nStructs,
            sizeof( oneDnaStruct), &compareDnaStructs);
 
-      result = mfeStructures->validStructs[0].correctedEnergy; //correct the energy 
- 
+      result = mfeStructures->validStructs[0].correctedEnergy; //correct the energy
+
       // Eliminate nonunique structures (only for MFE calculation)
-      if( fixedSubOptRange <= 0) {  
+      if( fixedSubOptRange <= 0) {
         // Eliminate duplicates, keep the right output permutation
         findUniqueMins(mfeStructures,nicks,symmetry,nStrands,0);
 
@@ -457,7 +478,7 @@
           }
           mfeStructures->nStructs = 1;
           mfeStructures->nAlloc = 1;
-          mfeStructures->minError = 0.0;  
+          mfeStructures->minError = 0.0;
         } else {
           findUniqueMins( mfeStructures, nicks, symmetry, nStrands, 0);
         }
@@ -467,27 +488,29 @@
         qsort(mfeStructures->validStructs,mfeStructures->nStructs,
           sizeof(oneDnaStruct),&compareDnaStructsOutput);
       }
-    } 
+    }
 
   free( seq);
   free( foldparens);
   seq = foldparens = NULL;
 
 
+/*
   free( F);
   free( Fb);
   free( Fm);
 
   F = Fb = Fm = NULL;
+*/
 
   if(complexity == 3) {
-   free( Fs);
-   free( Fms);
+   // free( Fs);
+   // free( Fms);
    free( Fx);
    free( Fx_1);
    free( Fx_2);
-   
-   Fs = Fms = Fx = Fx_1 = Fx_2 = NULL;
+
+   /* Fs = Fms = */ Fx = Fx_1 = Fx_2 = NULL;
   }
 
     if( complexity  >= 5) {
@@ -515,17 +538,28 @@
     }
   }
 
+/*
   for( i = 0; i <= seqlength-1; i++) {
     for( j = i-1; j <= seqlength-1; j++) {
       pf_ij = pf_index(i,j,seqlength);
       free( etaN[pf_ij]);
     }
   }
+*/
+  free( etaN[0] );
   free( etaN);
 
   free( maxILoopSize); maxILoopSize = NULL;
   free( minILoopEnergyBySize); minILoopEnergyBySize = NULL;
 
+  if (0) {
+    struct timeval stop;
+    gettimeofday(&stop, NULL);
+    float elapsed = (stop.tv_sec - start.tv_sec) * 1000.0f + (stop.tv_usec - start.tv_usec) / 1000.0f;
+    char txt[100];
+    sprintf(txt, "%7.2f", elapsed);
+    TraceJS(txt);
+  }
 
   return result;
 }
@@ -533,22 +567,22 @@
 
 
 /* ****************************** */
-DBL_TYPE mfe( int seq[], int seqLen, int *thepairs) { 
+DBL_TYPE mfe( int seq[], int seqLen, int *thepairs) {
   //ignores symmetry, single mfe, default parameters for DNA
   return mfeFull( seq, seqLen, thepairs, 3, DNA, 1, 37, 1.0, 0.0, 0);
 }
 
 
 /* ****************************** */
-DBL_TYPE mfeFull( int inputSeq[], int seqLen, int *thepairs, int complexity, 
+DBL_TYPE mfeFull( int inputSeq[], int seqLen, int *thepairs, int complexity,
                   int naType, int dangles, DBL_TYPE temperature,
-      DBL_TYPE sodiumconc, DBL_TYPE magnesiumconc, int uselongsalt) { 
+      DBL_TYPE sodiumconc, DBL_TYPE magnesiumconc, int uselongsalt) {
 //ignores symmetry, single mfe
   DBL_TYPE returnValue;
   int i;
 
   dnaStructures mfeStructures = {NULL, 0, 0, 0, 0}; //all structures withi epsilon of mfe
-  returnValue = mfeFullWithSym( inputSeq, seqLen, &mfeStructures, complexity, 
+  returnValue = mfeFullWithSym( inputSeq, seqLen, &mfeStructures, complexity,
         naType, dangles, temperature, 1, 1, sodiumconc, magnesiumconc,
         uselongsalt);
 
@@ -556,28 +590,28 @@
     thepairs[i] = mfeStructures.validStructs[0].theStruct[i];
   }
 
-  clearDnaStructures( &mfeStructures); 
+  clearDnaStructures( &mfeStructures);
   return returnValue;
 
 }
 
 
 /* ****************************** */
-DBL_TYPE mfeFullWithSym( int inputSeq[], int seqLen, 
-              dnaStructures *mfeStructures, int complexity, int naType, 
+DBL_TYPE mfeFullWithSym( int inputSeq[], int seqLen,
+              dnaStructures *mfeStructures, int complexity, int naType,
         int dangles, DBL_TYPE temperature, int symmetry, int onlyOne,
               DBL_TYPE sodiumconc, DBL_TYPE magnesiumconc, int uselongsalt) {
 
   int fixedSubOptRange = -1; //When < 0, will find mfe structures
 
-  return mfeFullWithSym_SubOpt( inputSeq, seqLen, mfeStructures, complexity, naType, 
+  return mfeFullWithSym_SubOpt( inputSeq, seqLen, mfeStructures, complexity, naType,
         dangles, temperature, symmetry, fixedSubOptRange, onlyOne,
         sodiumconc, magnesiumconc, uselongsalt);
 }
 
 /* ****************************** */
-//This function converts intpairs to parens notation 
-//allocate char *structure to seqlength + 1 before passing in 
+//This function converts intpairs to parens notation
+//allocate char *structure to seqlength + 1 before passing in
 
 void getStructure( int seqlength, const int thepairs[], char *structure) {
   int i;
@@ -608,11 +642,11 @@
   mfeStructures->nStructs = 1;
   mfeStructures->nAlloc = 1;
   mfeStructures->seqlength = seqlength;
-  mfeStructures->validStructs = (oneDnaStruct *) malloc( 1*sizeof( oneDnaStruct) ); 
+  mfeStructures->validStructs = (oneDnaStruct *) malloc( 1*sizeof( oneDnaStruct) );
   (mfeStructures->validStructs)[0].error = 0;
   (mfeStructures->validStructs)[0].correctedEnergy = 0;
   (mfeStructures->validStructs)[0].theStruct = (int *) malloc( seqlength*sizeof(int));
-  
+
   for( i = 0; i < seqlength; i++) {
     (mfeStructures->validStructs)[0].theStruct[i] = -1;
   }
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/min.c nupack3.0.4/src/thermo/utils/min.c
--- nupack3.0.4_stock/src/thermo/utils/min.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/min.c	2020-01-11 21:06:28.000000000 -0500
@@ -24,7 +24,8 @@
   int nNicks = 0;
 	
 	
-  index = EtaNIndex(i+0.5, j-0.5, seqlength);
+  //index = EtaNIndex(i+0.5, j-0.5, seqlength);
+  index = pf_index(IDX(i), IDX(j-1), seqlength);
   nNicks = etaN[ index][0];
 	
 	
@@ -48,8 +49,8 @@
   // Decomposes the region inside pair i,j into multiloops, i.e.
   // and excludes the possibility of "top level" nicks
 	
-  DBL_TYPE min_energy = 0.0;
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE min_energy;
+  DBL_TYPE bp_penalty;
   DBL_TYPE extraTerms;
   DBL_TYPE tempMin;
 	
@@ -58,10 +59,11 @@
   min_energy = NAD_INFINITY;
   if( ( seq[i]) + ( seq[j]) == 5) {
     for( d = i+3; d <= j - 2; d++) {
-      //reset loop parameters
-      bp_penalty = 0.0;
       
-      if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0 ) {
+      if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0 ) {
+        //reset loop parameters
+        bp_penalty = 0.0;
 				
 	if( seq[i] != BASE_C  && seq[j] != BASE_C) {
 	  bp_penalty += AT_PENALTY;
@@ -88,7 +90,7 @@
 	
   DBL_TYPE min_energy = NAD_INFINITY;
   DBL_TYPE tempMin;
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int multiNick = -1;
   int index_ij;
   int leftIndex;
@@ -98,13 +100,16 @@
 	
   DBL_TYPE extraTerms;
 	
-  index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  //index_ij = EtaNIndex(i+0.5, j-0.5, seqlength);
+  index_ij = pf_index(IDX(i), IDX(j-1), seqlength);
   
   iNicked = jNicked = FALSE;
-  if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(j-0.5, j-0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(j-1), IDX(j-1), seqlength)][0] != 0) {
     jNicked = TRUE;
   }
-  if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  //if( etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] != 0) {
+  if( etaN[ pf_index(IDX(i), IDX(i), seqlength)][0] != 0) {
     iNicked = TRUE;
   }
 	
@@ -158,8 +163,10 @@
 		
   int isEndNicked = FALSE;
 	
-  if( etaN[ EtaNIndex( i-0.5,i-0.5,seqlength)][0] == 1 || 
-      etaN[ EtaNIndex( j+0.5,j+0.5,seqlength)][0] == 1) 
+  //if( etaN[ EtaNIndex( i-0.5,i-0.5,seqlength)][0] == 1 || 
+  //    etaN[ EtaNIndex( j+0.5,j+0.5,seqlength)][0] == 1) 
+  if( etaN[ pf_index( IDX(i-1),IDX(i-1),seqlength)][0] == 1 || 
+      etaN[ pf_index( IDX(j),IDX(j),seqlength)][0] == 1) 
     isEndNicked = TRUE;
 	
   if( L >= 12) {
@@ -167,12 +174,12 @@
   }
 	
   //Use extensible cases              
-  if( CanPair( seq[ i], seq[j]) == TRUE) {
-    for( size = 8; size <= L - 4; size++) {
-			
+  if( CanPair( seq[ i], seq[j]) == TRUE && L >= 12) {
       extraTerms = InteriorMM( seq[i], seq[j], seq[i+1], 
-			       seq[j-1]);
+                               seq[j-1]);
       
+    for( size = 8; size <= L - 4; size++) {
+			
       tempMin = 
 	Fx[ fbixIndex( j-i, i, size, seqlength)] +
 	extraTerms;
@@ -211,14 +218,17 @@
   //Case 1:  L1 = 4, L2 >= 4;
   L1 = 4;
   d = i + L1 + 1;
+  if (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0)
   for( L2 = 4; L2 <= j - d - 2; L2++) {
-    size = L1 + L2;
     e = j - L2 - 1;
     
     if( CanPair( seq[d], seq[e]) == TRUE &&
-	(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	//(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	(etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
 			
+      size = L1 + L2;
       energy = asymmetryEfn( L1, L2, size) + InteriorMM( seq[e], seq[d], seq[e+1], seq[d-1]);
       /*Exclude the i-j stacking energy here, just in case i-j 
 	don't pair */
@@ -233,14 +243,17 @@
   //Case 2  L1 > 4, L2 = 4
   L2 = 4;
   e = j - L2 -1;
+  if (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0)
   for( L1 = 5; L1 <= e-i-2; L1++) {   
-    size = L1 + L2;
     d = i + L1 + 1;
     
     if( CanPair( seq[d], seq[e]) == TRUE &&
-	(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	//(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	//(etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) &&
+	(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) ) {
 			
+      size = L1 + L2;
       energy = asymmetryEfn( L1, L2, size) + InteriorMM( seq[e], seq[d], seq[e+1], seq[d-1]);
       /*Exclude the i-j stacking energy here, just in case i-j 
 	don't pair */
@@ -285,6 +298,8 @@
 	
 }
 
+int (*binding_cb)(int i, int j, int* d, int*e) = NULL;
+
 /* ****************** */
 DBL_TYPE MinInextensibleIL( int i, int j, int seq[], int seqlength, 
 			    DBL_TYPE Fb[], int **etaN, DBL_TYPE *minILoopEnergyBySize) {
@@ -305,14 +320,17 @@
   
   for( L1 = 0; L1 <= 3; L1++) {
     d = i + L1 + 1;
+    if (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] != 0) continue;
     for( L2 = 0; L2 <= MIN( 3, j-d-2); L2++) {
       e = j - L2 - 1;
-      size = L1 + L2;
 			
       if( CanPair( seq[d], seq[e]) == TRUE &&
-	  (etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	  (etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
 				
+        size = L1 + L2;
 	energy = InteriorEnergy( i, j, d, e, seq);
 				
 	tempMin = energy + 
@@ -327,15 +345,18 @@
   // Case 2a  L1 = 0,1,2,3, L2 >= 4;
   for( L1 = 0; L1 <= 3; L1++) {
     d = i + L1 + 1;
+    if (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] != 0) continue;
     for( L2 = 4; L2 <= j - d - 2; L2++) {
       e = j - L2 - 1;
-      size = L1 + L2;
 
       if( CanPair( seq[d], seq[e]) == TRUE &&
-	  (etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	  (etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
 				
 				
+        size = L1 + L2;
 	energy = InteriorEnergy( i, j, d, e, seq);	
 				
 	tempMin = energy +
@@ -349,14 +370,17 @@
   // Case 2b L1 >= 4, L2 = 0,1,2,3;
   for( L2 = 0; L2 <= 3; L2++) {
     e = j - L2 - 1;
+    if (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] != 0) continue;
     for( L1 = 4;  L1 <= e - i - 2; L1++) {
       d = i + L1 + 1;
-      size = L1 + L2;
 			
       if( CanPair( seq[d], seq[e]) == TRUE &&
-	  (etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
-	  (etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  //(etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) ) {
 				
+        size = L1 + L2;
 	energy = InteriorEnergy( i, j, d, e, seq);
 	tempMin = energy + 
 	  Fb[ pf_index( d, e, seqlength)];
@@ -366,6 +390,26 @@
     }
   }    
 	
+  // EteRNA binding site hack
+  if (binding_cb != NULL) {
+    if ((*binding_cb)(i, j, &d, &e)) {
+      size = d - i + j - e;
+
+      if( CanPair( seq[d], seq[e]) == TRUE &&
+	  //(etaN[ EtaNIndex(i+0.5, d-0.5,seqlength)][0] == 0) &&
+	  //(etaN[ EtaNIndex(e+0.5, j-0.5,seqlength)][0] == 0) ) {
+	  (etaN[ pf_index(IDX(i), IDX(d-1),seqlength)][0] == 0) &&
+	  (etaN[ pf_index(IDX(e), IDX(j-1),seqlength)][0] == 0) ) {
+				
+	energy = InteriorEnergy( i, j, d, e, seq);
+	tempMin = energy + 
+	  Fb[ pf_index( d, e, seqlength)];
+	min_energy = MIN( min_energy, tempMin);
+	minILoopEnergyBySize[ size] = MIN( tempMin, minILoopEnergyBySize[size]);
+      }
+    }
+  }
+
   return min_energy;
 }
 
@@ -377,12 +421,13 @@
                   int *nicks, int **etaN) {
   
   int d; //base pair is i,d
-  DBL_TYPE bp_penalty = 0.0;
+  DBL_TYPE bp_penalty;
   int pf_ij = pf_index( i, j, seqlength);
   
   DBL_TYPE extraTerms;
   int nNicks;
-  int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  //int index_ij = EtaNIndex( i+0.5, j-0.5, seqlength);
+  int index_ij = pf_index( IDX(i), IDX(j-1), seqlength);
   int start;
   DBL_TYPE tempMin;
   
@@ -395,11 +440,11 @@
   }
   
   for( d = start; d <= j; d++) {
-    bp_penalty = 0.0;
     
     if( CanPair( seq[i], seq[ d]) == TRUE &&
        ( seq[i]) + ( seq[d]) == 5) {
          
+         bp_penalty = 0.0;
          if( seq[i] != BASE_C && seq[d] != BASE_C) {
            bp_penalty = AT_PENALTY;
          }
@@ -442,19 +487,22 @@
  F[ pf_ij] = NickedEmptyF( i, j, nicks, seq, seqlength, etaN);
  
  for( d = i; d <= j - 1; d++) {
-   if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   //if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 || d == i ) {
+   if( etaN[ pf_index(IDX(d-1), IDX(d-1), seqlength)][0] == 0 || d == i ) {
      
      tempMin = F[ pf_index(i, d-1, seqlength)] + Fs[ pf_index( d, j, seqlength)];
      F[ pf_ij] = MIN( tempMin, F[ pf_ij]);
      
-     extraTerms = DangleEnergy( i, d-1, seq, seqlength) +
-       (ALPHA_3)*(d-i);
-     
      
-     if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     //if( etaN[ EtaNIndex( d-0.5, d-0.5, seqlength)][0] == 0) { 
+     if( etaN[ pf_index( IDX(d-1), IDX(d-1), seqlength)][0] == 0) { 
        //otherwise Qm not possible
        
-       if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       //if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0 ) {
+       if( etaN[ pf_index(IDX(i), IDX(d-1), seqlength)][0] == 0 ) {
+         extraTerms = DangleEnergy( i, d-1, seq, seqlength) +
+           (ALPHA_3)*(d-i);
+     
          tempMin = Fms[ pf_index( d, j, seqlength)] +
            extraTerms;
          Fm[ pf_ij] = MIN( tempMin, Fm[ pf_ij]);
@@ -484,28 +532,36 @@
   DBL_TYPE min_energy = NAD_INFINITY;
   DBL_TYPE tempMin;
   int d, e; // d - e is internal basepair 
-  DBL_TYPE bp_penalty = 0;
+  DBL_TYPE bp_penalty;
 	
 	
   for( d = i+1; d <= j - 5; d++) {
+    int eta_id = etaN[ pf_index(IDX(i), IDX(d-1), seqlength)][0];
+    int eta_dd = etaN[ pf_index(IDX(d-1), IDX(d-1), seqlength)][0];
+    int eta_ii = etaN[ pf_index(IDX(i), IDX(i), seqlength)][0];
+    if (eta_id != 0 && (eta_dd != 0 || eta_ii != 0)) continue;
     for( e = d + 4; e <= j - 1; e++) {
       if( CanPair( seq[d], seq[e]) == TRUE) {
-        bp_penalty = 0.0;
 				
-	if( etaN[ EtaNIndex(e+0.5, j-0.5, seqlength)][0] == 0) {
+	//if( etaN[ EtaNIndex(e+0.5, j-0.5, seqlength)][0] == 0) {
+	if( etaN[ pf_index(IDX(e), IDX(j-1), seqlength)][0] == 0) {
 				
-	  if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0) {
+	  //if( etaN[ EtaNIndex(i+0.5, d-0.5, seqlength)][0] == 0) {
+	  if( eta_id == 0) {
 	    tempMin = InteriorEnergy( i, j, d, e, seq) +
 	      Fb[ pf_index( d, e, seqlength) ];
 					
 	    min_energy = MIN( tempMin, min_energy);
 	  }
 					
-	  if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 &&
-	      etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
+	  //if( etaN[ EtaNIndex(d-0.5, d-0.5, seqlength)][0] == 0 &&
+	  //    etaN[ EtaNIndex(i+0.5, i+0.5, seqlength)][0] == 0 &&
+	  if( eta_dd == 0 &&
+	      eta_ii == 0 &&
 	      d>= i+6 && ( seq[d]) + ( seq[e]) == 5 &&
 	      ( seq[i]) + ( seq[j]) == 5 ) {
 						
+            bp_penalty = 0.0;
 	    if( seq[d] != BASE_C && seq[e] != BASE_C) {
 	      bp_penalty = AT_PENALTY;
 	    }
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/nsStar.c nupack3.0.4/src/thermo/utils/nsStar.c
--- nupack3.0.4_stock/src/thermo/utils/nsStar.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/nsStar.c	2020-01-11 21:06:28.000000000 -0500
@@ -10,7 +10,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <memory.h>
+//#include <memory.h>
 #include <math.h>
 #include <string.h>
 #include <ctype.h>
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/pairsPr.c nupack3.0.4/src/thermo/utils/pairsPr.c
--- nupack3.0.4_stock/src/thermo/utils/pairsPr.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/pairsPr.c	2020-01-11 21:06:28.000000000 -0500
@@ -64,7 +64,7 @@
 
   value = -b/a + 1.0;
 
-  precisionLost = (float) -1*log2l(value);
+  precisionLost = (float) -1*log(value)/log(2);
 
 #ifdef DEBUG
   if( a < 0) printf("%Le %Le %f\n", (long double) a, (long double) b, precisionLost);
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/pfuncUtils.c nupack3.0.4/src/thermo/utils/pfuncUtils.c
--- nupack3.0.4_stock/src/thermo/utils/pfuncUtils.c	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/pfuncUtils.c	2020-01-11 21:06:28.000000000 -0500
@@ -9,7 +9,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
-#include <memory.h>
+//#include <memory.h>
 #include <ctype.h>
 
 #include "pfuncUtilsHeader.h" //contains functions and structures
@@ -220,13 +220,28 @@
 
 /* *********************************************************** */ 
 int GetMismatchShift( int base1, int base2) {
+  static int shifts[64] = {
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1,  0, -1, -1, -1,
+    -1, -1, -1,  1, -1, -1, -1, -1,
+    -1, -1,  2, -1,  4, -1, -1, -1,
+    -1,  3, -1,  5, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1
+  };
+  
+  return shifts[((base1 & 0x7) << 3) | (base2 & 0x7)];
+  
+}
+
+int GetMismatchShiftOld( int base1, int base2) {
   /* base1 and base2 are basepaired. the returned value is needed to 
   index energy arrays
   */
   int shift;
   
-  if( base1 == BASE_A) { /* this is for retrieving 
-  proper mismatch energy */
+  if( base1 == BASE_A) { /* this is for retrieving proper mismatch energy */
     shift = 0;
   }
   else if( base1 == BASE_C) {
@@ -253,7 +268,11 @@
 }
 
 /* ************************************************** */
-int GetPairType( int b) { //assume pair of b is the watson crick pair
+int GetPairType(int b) {
+  return b >= BASE_A && b <= BASE_T ? b-1: -1;
+}
+
+int GetPairTypeOld( int b) { //assume pair of b is the watson crick pair
   int shift;
   
   if( b == BASE_A) { 
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/pfuncUtilsConstants.h nupack3.0.4/src/thermo/utils/pfuncUtilsConstants.h
--- nupack3.0.4_stock/src/thermo/utils/pfuncUtilsConstants.h	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/pfuncUtilsConstants.h	2020-01-11 21:06:28.000000000 -0500
@@ -34,7 +34,7 @@
 #endif
 
 
-
+#define USE_DOUBLE
 //sets the type of floating point variables
 #ifdef USE_DOUBLE
 
@@ -60,10 +60,10 @@
 #define MAXPRECERR 24 //max error in bits of precision
 
 //Maximum seqeuence length
-#define MAXSEQLENGTH 10000
+#define MAXSEQLENGTH 1000
 
 //maximum # of strands in a complex
-#define MAXSTRANDS 2000
+#define MAXSTRANDS 20
  
 //MATCH_PF will make the energy model used in energy calculations
 //match the one used in mfe and partition function calculations.
diff -X .gitignore -ur nupack3.0.4_stock/src/thermo/utils/pfuncUtilsHeader.h nupack3.0.4/src/thermo/utils/pfuncUtilsHeader.h
--- nupack3.0.4_stock/src/thermo/utils/pfuncUtilsHeader.h	2014-03-15 18:04:18.000000000 -0400
+++ nupack3.0.4/src/thermo/utils/pfuncUtilsHeader.h	2020-01-11 21:06:28.000000000 -0500
@@ -22,7 +22,7 @@
 #include "pfuncUtilsConstants.h"
 #include "runtime_constants.h"
 #include "physical_constants.h"
-#include "../../shared/utilsHeader.h"
+#include "utilsHeader.h"
 
 /* ************************ */
 // Macros
@@ -326,10 +326,11 @@
 /* ******************************************************************************** */
 //pf_index calculates the array index for a Q-type array
 int pf_index_old( int i, int j, int N);
-#define pf_index(i,j,N) ((j)==(i)-1?(N)*((N)+1)/2 + (i) : ((i)*(N)+(j)-(i)*(1+(i))/2))
-#define pf_index_same(i,N) ((i)*(N)-(i)*((i)-1)/2)
+#define pf_index(i,j,N) ((j)==(i)-1?(((N)*((N)+1))>>1) + (i) : ((i)*(N)+(j)-(((i)*(1+(i)))>>1)))
+#define pf_index_same(i,N) ((i)*(N)-(((i)*((i)-1))>>1))
 #define EtaNIndex(i,j,N) pf_index((int)(i),(int)(j),N)
 #define EtaNIndex_same(i,N) pf_index_same((int)(i),N)
+#define IDX(a) ((a)<0?0:(a))
 //((int)(j)==(int)(i)-1?(int)((N)*((N)+1)/2 + (int)(i)) : ((int)(i)*(N)+(j)-(i)*(1+(i))/2))
 //gap_index calculates the array index of a "gap" matrix.
 int gap_index( int h, int r, int m, int s, int seqlength);
