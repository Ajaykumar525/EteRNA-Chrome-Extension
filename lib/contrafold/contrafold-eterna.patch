Only in contrafold/src: contrafold
Only in contrafold/src: Contrafold.cpp.orig
Only in contrafold/src: Contrafold.o
Only in contrafold/src: Defaults.ipp
Only in contrafold/src: FileDescription.o
diff -X .gitignore -ur contrafold_stock/src/InferenceEngine.ipp contrafold/src/InferenceEngine.ipp
--- contrafold_stock/src/InferenceEngine.ipp	2020-03-27 14:51:42.086266204 -0400
+++ contrafold/src/InferenceEngine.ipp	2020-03-25 16:42:30.228287230 -0400
@@ -2,6 +2,9 @@
 // InferenceEngine.ipp
 //////////////////////////////////////////////////////////////////////
 
+/* for AS3 */
+void (*eos_cb)(int index, int fe);
+
 //////////////////////////////////////////////////////////////////////
 // Wrapper macros for certain model features.
 //////////////////////////////////////////////////////////////////////
@@ -1372,7 +1375,8 @@
                 CountBasePair(i+1,j-1,reverse_sums[(i+j)*L+j-i].second);
                 if (allow_paired[offset[i]+j])
                 {
-                    CountHelixStacking(i,j,reverse_sums[(i+j)*L+j-i].second);
+                    CountHelixStacking(i,j,reverse_sums[(i+j)*L+j-i].second);			
+                    // if (eos_cb) (*eos_cb)(i, floor(.5 + reverse_sums[(i+j)*L+j-i].second * 100.));
                 }
                 else
                 {
@@ -1766,6 +1770,25 @@
     // we allow i to be as large as L and j to be as small as 0.
     
     Assert(0 < i && i <= L && 0 <= j && j < L, "Invalid indices.");
+    
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + ( 0
+// #if PARAMS_HELIX_CLOSING
+// #if PROFILE
+//         + profile_score_helix_closing[i*(L+1)+j].first
+// #else                                          
+//         + score_helix_closing[s[i]][s[j+1]].first
+// #endif
+// #endif
+// #if PARAMS_DANGLE
+// #if PROFILE
+//         + (i < L ? profile_score_dangle_left[i*(L+1)+j].first : RealT(0))
+//         + (j > 0 ? profile_score_dangle_right[i*(L+1)+j].first : RealT(0))
+// #else
+//         + (i < L ? score_dangle_left[s[i]][s[j+1]][s[i+1]].first : RealT(0))
+//         + (j > 0 ? score_dangle_right[s[i]][s[j+1]][s[j]].first : RealT(0))
+// #endif
+// #endif
+//     ) * 100.));
 
     return
         RealT(0)
@@ -1793,6 +1816,8 @@
 {
     Assert(0 < i && i <= L && 0 <= j && j < L, "Invalid indices.");
     
+    //AMW
+
 #if PARAMS_HELIX_CLOSING
 #if PROFILE
     profile_score_helix_closing[i*(L+1)+j].second += value;
@@ -1843,6 +1868,23 @@
     
     Assert(0 < i && i < L && 0 < j && j < L, "Invalid indices.");
     
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + ( 0
+// #if PARAMS_HELIX_CLOSING
+// #if PROFILE
+//         + profile_score_helix_closing[i*(L+1)+j].first
+// #else
+//         + score_helix_closing[s[i]][s[j+1]].first
+// #endif
+// #endif
+// #if PARAMS_TERMINAL_MISMATCH
+// #if PROFILE
+//         + profile_score_terminal_mismatch[i*(L+1)+j].first
+// #else                                           
+//         + score_terminal_mismatch[s[i]][s[j+1]][s[i+1]][s[j]].first
+// #endif
+// #endif
+//     ) * 100 ) );
+
     return RealT(0)
 #if PARAMS_HELIX_CLOSING
 #if PROFILE
@@ -1866,6 +1908,7 @@
 {
     Assert(0 < i && i < L && 0 < j && j < L, "Invalid indices.");
     
+    //AMW
 #if PARAMS_HELIX_CLOSING
 #if PROFILE
     profile_score_helix_closing[i*(L+1)+j].second += value;
@@ -1898,6 +1941,22 @@
     
     Assert(0 < i && i <= L && 0 < j && j <= L && i != j, "Invalid base-pair");
     
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + ( 0
+// #if defined(HAMMING_LOSS)
+//         + loss_paired[offset[i]+j]
+// #endif
+// #if PARAMS_BASE_PAIR
+// #if PROFILE
+//         + profile_score_base_pair[i*(L+1)+j].first
+// #else
+//         + score_base_pair[s[i]][s[j]].first
+// #endif
+// #endif
+// #if PARAMS_BASE_PAIR_DIST
+//         + cache_score_base_pair_dist[std::min(Abs(j - i), BP_DIST_LAST_THRESHOLD)].first
+// #endif
+//     ) * 100 ));
+
     return RealT(0)
 #if defined(HAMMING_LOSS)
         + loss_paired[offset[i]+j]
@@ -1920,6 +1979,7 @@
 {
     Assert(0 < i && i <= L && 0 < j && j <= L && i != j, "Invalid base-pair");
     
+    // AMW
 #if PARAMS_BASE_PAIR
 #if PROFILE
     profile_score_base_pair[i*(L+1)+j].second += value;
@@ -1961,6 +2021,27 @@
     
     Assert(0 < i && i + C_MIN_HAIRPIN_LENGTH <= j && j < L, "Hairpin boundaries invalid.");
     
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + (ScoreUnpaired(i,j)
+//         + ScoreJunctionB(i,j)
+// #if PARAMS_HAIRPIN_LENGTH
+//         + cache_score_hairpin_length[std::min(j - i, D_MAX_HAIRPIN_LENGTH)].first
+// #endif
+// #if PARAMS_HAIRPIN_3_NUCLEOTIDES
+// #if PROFILE
+//         + (j - i == 3 ? profile_score_hairpin_3_nucleotides[i].first : RealT(0))
+// #else
+//         + (j - i == 3 ? score_hairpin_3_nucleotides[s[i+1]][s[i+2]][s[i+3]].first : RealT(0))
+// #endif                                          
+// #endif
+// #if PARAMS_HAIRPIN_4_NUCLEOTIDES
+// #if PROFILE
+//         + (j - i == 4 ? profile_score_hairpin_4_nucleotides[i].first : RealT(0))
+// #else
+//         + (j - i == 4 ? score_hairpin_4_nucleotides[s[i+1]][s[i+2]][s[i+3]][s[i+4]].first : RealT(0))
+// #endif
+// #endif
+//     ) * 100 ));
+
     return 
         ScoreUnpaired(i,j)
         + ScoreJunctionB(i,j)
@@ -1989,6 +2070,7 @@
 {
     Assert(0 < i && i + C_MIN_HAIRPIN_LENGTH <= j && j < L, "Hairpin boundaries invalid.");
     
+    //AMW
     CountUnpaired(i,j,value);
     CountJunctionB(i,j,value);
 #if PARAMS_HAIRPIN_LENGTH
@@ -2042,6 +2124,28 @@
     Assert(0 <= i && i + 2 * m <= j && j <= L, "Helix boundaries invalid.");
     Assert(2 <= m && m <= D_MAX_HELIX_LENGTH, "Helix length invalid.");
     
+// #if FAST_HELIX_LENGTHS
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + (
+
+//         cache_score_helix_sums[(i+j+1)*L+j-i-1].first - cache_score_helix_sums[(i+j+1)*L+j-i-m-m+1].first
+// #if PARAMS_HELIX_LENGTH
+//         + cache_score_helix_length[m].first
+// #endif
+//     ) * 100 ) );
+// #else 
+
+//     RealT ret = RealT(0);
+//     for (int k = 1; k < m; k++)
+//         ret += ScoreHelixStacking(i+k,j-k+1) + ScoreBasePair(i+k+1,j-k);
+    
+// #if PARAMS_HELIX_LENGTH
+//     ret += cache_score_helix_length[m].first;
+// #endif
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + (ret) * 100 ) );
+// #endif
+
+
+
 #if FAST_HELIX_LENGTHS
     
     return
@@ -2136,6 +2240,61 @@
     Assert(l1 + l2 > 0 && l1 >= 0 && l2 >= 0 && l1 + l2 <= C_MAX_SINGLE_LENGTH, "Invalid single-branch loop size.");
 #endif
     
+//     if (eos_cb) (*eos_cb)(i, floor(.5 + (ScoreUnpaired(i,p)
+//         + ScoreUnpaired(q,j)
+// #if PARAMS_BULGE_0x1_NUCLEOTIDES
+// #if PROFILE
+//         + (l1 == 0 && l2 == 1 ? profile_score_bulge_0x1_nucleotides[j].first : RealT(0))
+//         + (l1 == 1 && l2 == 0 ? profile_score_bulge_1x0_nucleotides[i].first : RealT(0))
+// #else
+//         + (l1 == 0 && l2 == 1 ? score_bulge_0x1_nucleotides[s[j]].first : RealT(0))
+//         + (l1 == 1 && l2 == 0 ? score_bulge_1x0_nucleotides[s[i+1]].first : RealT(0))
+// #endif
+// #endif
+// #if PARAMS_BULGE_0x2_NUCLEOTIDES
+// #if PROFILE
+//         + (l1 == 0 && l2 == 2 ? profile_score_bulge_0x2_nucleotides[j].first : RealT(0))
+//         + (l1 == 2 && l2 == 0 ? profile_score_bulge_2x0_nucleotides[i].first : RealT(0))
+// #else
+//         + (l1 == 0 && l2 == 2 ? score_bulge_0x2_nucleotides[s[j-1]][s[j]].first : RealT(0))
+//         + (l1 == 2 && l2 == 0 ? score_bulge_2x0_nucleotides[s[i+1]][s[i+2]].first : RealT(0))
+// #endif
+// #endif
+// #if PARAMS_BULGE_0x3_NUCLEOTIDES
+// #if PROFILE
+//         + (l1 == 0 && l2 == 3 ? profile_score_bulge_0x3_nucleotides[j].first : RealT(0))
+//         + (l1 == 3 && l2 == 0 ? profile_score_bulge_3x0_nucleotides[i].first : RealT(0))
+// #else
+//         + (l1 == 0 && l2 == 3 ? score_bulge_0x3_nucleotides[s[j-2]][s[j-1]][s[j]].first : RealT(0))
+//         + (l1 == 3 && l2 == 0 ? score_bulge_3x0_nucleotides[s[i+1]][s[i+2]][s[i+3]].first : RealT(0))
+// #endif
+// #endif
+// #if PARAMS_INTERNAL_1x1_NUCLEOTIDES
+// #if PROFILE
+//         + (l1 == 1 && l2 == 1 ? profile_score_internal_1x1_nucleotides[i*(L+1)+j].first : RealT(0))
+// #else
+//         + (l1 == 1 && l2 == 1 ? score_internal_1x1_nucleotides[s[i+1]][s[j]].first : RealT(0))
+// #endif
+// #endif
+// #if PARAMS_INTERNAL_1x2_NUCLEOTIDES
+// #if PROFILE
+//         + (l1 == 1 && l2 == 2 ? profile_score_internal_1x2_nucleotides[i*(L+1)+j].first : RealT(0))
+//         + (l1 == 2 && l2 == 1 ? profile_score_internal_2x1_nucleotides[i*(L+1)+j].first : RealT(0))
+// #else
+//         + (l1 == 1 && l2 == 2 ? score_internal_1x2_nucleotides[s[i+1]][s[j-1]][s[j]].first : RealT(0))
+//         + (l1 == 2 && l2 == 1 ? score_internal_2x1_nucleotides[s[i+1]][s[i+2]][s[j]].first : RealT(0))
+// #endif
+// #endif
+// #if PARAMS_INTERNAL_2x2_NUCLEOTIDES
+// #if PROFILE
+//         + (l1 == 2 && l2 == 2 ? profile_score_internal_2x2_nucleotides[i*(L+1)+j].first : RealT(0))
+// #else                                                                   
+//         + (l1 == 2 && l2 == 2 ? score_internal_2x2_nucleotides[s[i+1]][s[i+2]][s[j-1]][s[j]].first : RealT(0))
+// #endif
+// #endif
+//     ) * 100 ) );
+
+
     return 
         ScoreUnpaired(i,p)
         + ScoreUnpaired(q,j)
@@ -2297,6 +2456,13 @@
     Assert(0 < i && i <= p && p + 2 <= q && q <= j && j < L, "Single-branch loop boundaries invalid.");
     Assert(l1 + l2 > 0 && l1 >= 0 && l2 >= 0 && l1 + l2 <= C_MAX_SINGLE_LENGTH, "Invalid single-branch loop size.");
     
+    // if (eos_cb) (*eos_cb)(i, floor(.5 + (cache_score_single[l1][l2].first
+    //     + ScoreBasePair(p+1,q)
+    //     + ScoreJunctionB(i,j) 
+    //     + ScoreJunctionB(q,p)
+    //     + ScoreSingleNucleotides(i,j,p,q)) * 100 ) );
+
+
     return 
         cache_score_single[l1][l2].first
         + ScoreBasePair(p+1,q)
@@ -3300,6 +3466,7 @@
                 Fast_LogPlusEquals(sum_i, FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase());
                 
                 FNi[offset[i]+j] = sum_i;
+                if (eos_cb) (*eos_cb)(i, floor(0.5 + sum_i * 100));
             }
             
             // FE[i,j] = optimal energy for substructure between positions
@@ -3327,6 +3494,7 @@
                 Fast_LogPlusEquals(sum_i, FNi[offset[i]+j]);
                 
                 FEi[offset[i]+j] = sum_i;
+                if (eos_cb) (*eos_cb)(i, floor(0.5 + sum_i * 100));
             }
             
             // FC[i,j] = optimal energy for substructure between positions
@@ -3366,6 +3534,7 @@
                 }
                 
                 FCi[offset[i]+j] = sum_i;
+                if (eos_cb) (*eos_cb)(i, floor(0.5 + sum_i * 100));
             }
             
 #else
@@ -3441,6 +3610,7 @@
                 Fast_LogPlusEquals(sum_i, FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase());
                 
                 FCi[offset[i]+j] = sum_i;
+                if (eos_cb) (*eos_cb)(i, floor(0.5 + sum_i * 100));
             }
             
 #endif
@@ -3471,6 +3641,7 @@
                     Fast_LogPlusEquals(sum_i, FM1i[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
                 
                 FM1i[offset[i]+j] = sum_i;
+                if (eos_cb) (*eos_cb)(i, floor(0.5 + sum_i * 100));
             }
             
             // FM[i,j] = optimal energy for substructure belonging to a
@@ -3502,6 +3673,7 @@
                 Fast_LogPlusEquals(sum_i, FM1i[offset[i]+j]);
                 
                 FMi[offset[i]+j] = sum_i;
+                if (eos_cb) (*eos_cb)(i, floor(0.5 + sum_i * 100));
             }
         }
     }
@@ -3530,6 +3702,7 @@
                 Fast_LogPlusEquals(sum_i, F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() + ScoreBasePair(k+1,j) + ScoreJunctionA(j,k));
         
         F5i[j] = sum_i;
+        if (eos_cb) (*eos_cb)(j, floor(0.5 + sum_i * 100));
     }
 
 #if SHOW_TIMINGS
Only in contrafold/src: InferenceEngine.ipp.orig
diff -X .gitignore -ur contrafold_stock/src/LBFGS.ipp contrafold/src/LBFGS.ipp
--- contrafold_stock/src/LBFGS.ipp	2020-03-27 14:51:42.086266204 -0400
+++ contrafold/src/LBFGS.ipp	2020-03-25 16:42:30.228287230 -0400
@@ -107,7 +107,7 @@
 
         // perform line search, update f, and take step
 
-        Real step = DoLineSearch(x[k%2], f[k%2], g[k%2], d,
+        Real step = this->DoLineSearch(x[k%2], f[k%2], g[k%2], d,
                                  x[(k+1)%2], f[(k+1)%2], g[(k+1)%2],
                                  Real(0), std::min(Real(10), MAX_STEP_NORM / std::max(Real(1), Norm(d))));
         
Only in contrafold/src: LBFGS.ipp.orig
Only in contrafold/src: Options.o
diff -X .gitignore -ur contrafold_stock/src/ParameterManager.ipp contrafold/src/ParameterManager.ipp
--- contrafold_stock/src/ParameterManager.ipp	2020-03-27 14:51:42.090266506 -0400
+++ contrafold/src/ParameterManager.ipp	2020-03-25 16:42:30.228287230 -0400
@@ -1,8 +1,13 @@
+#pragma once
+
 //////////////////////////////////////////////////////////////////////
 // ParameterManager.ipp
 //////////////////////////////////////////////////////////////////////
 
-#include "ParameterManager.hpp"
+#ifndef PARAMETERMANAGER_IPP
+#define PARAMETERMANAGER_IPP
+
+// #include "ParameterManager.hpp"
 
 //////////////////////////////////////////////////////////////////////
 // ParameterGroup::ParameterGroup()
@@ -266,3 +271,5 @@
     if (iter == physical_to_logical.end()) Error("Request for unknown physical parameter.");
     return iter->second;
 }
+
+#endif
\ No newline at end of file
Only in contrafold/src: ParameterManager.ipp.orig
Only in contrafold/src: score_prediction
Only in contrafold/src: ScorePrediction.o
diff -X .gitignore -ur contrafold_stock/src/SStruct.cpp contrafold/src/SStruct.cpp
--- contrafold_stock/src/SStruct.cpp	2020-03-27 14:51:42.086266204 -0400
+++ contrafold/src/SStruct.cpp	2020-03-27 14:18:34.295403138 -0400
@@ -61,6 +61,37 @@
 }
 
 //////////////////////////////////////////////////////////////////////
+// SStruct::LoadString()
+//
+// Load from string.
+//////////////////////////////////////////////////////////////////////
+
+void SStruct::LoadString(const std::string &string)
+{
+    // clear any previous data
+    std::vector<std::string>().swap(names);
+    std::vector<std::string>().swap(sequences);
+    std::vector<int>().swap(mapping);
+
+    // initialize
+    names.push_back("no_file");
+    sequences.push_back("@" + string);
+
+    // sanity-checks
+    if (sequences[0].length() == 1) Error("Zero-length sequence read.");
+
+    // initialize empty secondary structure
+    mapping.resize(sequences[0].length(), UNKNOWN);
+
+    // perform character conversions
+    for (size_t i = 0; i < sequences.size(); i++)
+        sequences[i] = FilterSequence(sequences[i]);
+
+    // error-checking
+    ValidateMapping(mapping);
+}
+
+//////////////////////////////////////////////////////////////////////
 // SStruct::AnalyzeFormat()
 //
 // Determine file format.
@@ -391,6 +422,7 @@
     std::vector<int> mapping(parens.length(), UNKNOWN);
     std::vector<int> stack;
    
+    std::cout << parens << std::endl;
     Assert(parens[0] == '@', "Invalid parenthesized string.");
     for (int i = 1; i < int(parens.length()); i++)
     {
Only in contrafold/src: SStruct.cpp.orig
Only in contrafold/src: SStruct.cpp.rej
diff -X .gitignore -ur contrafold_stock/src/SStruct.hpp contrafold/src/SStruct.hpp
--- contrafold_stock/src/SStruct.hpp	2020-03-27 14:51:42.090266506 -0400
+++ contrafold/src/SStruct.hpp	2020-03-25 16:42:30.228287230 -0400
@@ -40,9 +40,11 @@
     std::string FilterSequence(std::string sequence) const;
     std::string FilterParens(std::string sequence) const;
 
+public:
     // convert a pseudoknot-free parenthesized structure to a mapping and back
     std::vector<int> ConvertParensToMapping(const std::string &parens) const;
     std::string ConvertMappingToParens(const std::vector<int> &mapping) const;
+    void LoadString(const std::string &seq);
 
     // check that a (possibly pseudoknotted) mapping is valid
     void ValidateMapping(const std::vector<int> &mapping) const;
Only in contrafold/src: SStruct.hpp.orig
Only in contrafold/src: SStruct.o
diff -X .gitignore -ur contrafold_stock/src/Utilities.cpp contrafold/src/Utilities.cpp
--- contrafold_stock/src/Utilities.cpp	2020-03-27 14:51:42.090266506 -0400
+++ contrafold/src/Utilities.cpp	2020-03-25 16:42:30.228287230 -0400
@@ -2,6 +2,7 @@
 // Utilities.cpp
 //////////////////////////////////////////////////////////////////////
 
+#include <limits.h>
 #include "Utilities.hpp"
 
 bool toggle_error = false;
Only in contrafold/src: Utilities.cpp.orig
Only in contrafold/src: Utilities.o
